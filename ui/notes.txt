Node --- 
Dependencies attribute is used for production environment while devDependencies are used for local development environment.
dependencies are install when using npm install on a directory having package.json or npm install $package on other directory not having packge.json
devDependencies are installed using npm install on a directory having package.json unless --production is supplied so if we run 
npm install --production then devDependencies are not installed or if we run npm install $package on a directory not having package.json file then deveDependencies are not installed unless we give --dev option.

Grunt -- 
watch options

these braces are just to create a holder for examples below which helps in rolling the code up they are not required in actual code
{
    options.spawn
    Type: Boolean
    Default: true

    Whether to spawn task runs in a child process. Setting this option to false speeds up the reaction time of the watch (usually 500ms faster for most) and allows subsequent task runs to share the same context. Not spawning task runs can make the watch more prone to failing so please use as needed.

    Example:

    watch: {
    scripts: {
        files: ['**/*.js'],
        tasks: ['jshint'],
        options: {
        spawn: false,
        },
    },
    },
    For backwards compatibility the option nospawn is still available and will do the opposite of spawn.

    options.interrupt
    Type: Boolean
    Default: false

    As files are modified this watch task will spawn tasks in child processes. The default behavior will only spawn a new child process per target when the previous process has finished. Set the interrupt option to true to terminate the previous process and spawn a new one upon later changes.

    Example:

    watch: {
    scripts: {
        files: '**/*.js',
        tasks: ['jshint'],
        options: {
        interrupt: true,
        },
    },
    },

    options.event
    Type: String|Array
    Default: 'all'

    Specify the type of watch events that triggers the specified task. This option can be one or many of: 'all', 'changed', 'added' and 'deleted'.

    Example:

    watch: {
    scripts: {
        files: '**/*.js',
        tasks: ['generateFileManifest'],
        options: {
        event: ['added', 'deleted'],
        },
    },
    },

    options.reload
    Type: Boolean
    Default: false

    By default, if Gruntfile.js is being watched, then changes to it will trigger the watch task to restart, and reload the Gruntfile.js changes. When reload is set to true, changes to any of the watched files will trigger the watch task to restart. This is especially useful if your Gruntfile.js is dependent on other files.

    watch: {
    configFiles: {
        files: [ 'Gruntfile.js', 'config/*.js' ],
        options: {
        reload: true
        }
    }
    }

    options.livereload
    Type: Boolean|Number|Object
    Default: false

    Set to true or set livereload: 1337 to a port number to enable live reloading. Default and recommended port is 35729.

    If enabled a live reload server will be started with the watch task per target. Then after the indicated tasks have run, the live reload server will be triggered with the modified files.

    See also how to enable livereload on your HTML.

    Example:

    watch: {
    css: {
        files: '**/*.sass',
        tasks: ['sass'],
        options: {
        livereload: true,
        },
    },
    },
    Passing an object to livereload allows listening on a specific port and hostname/IP or over https connections (by specifying key and cert paths).

    Example:

    watch: {
    css: {
        files: '**/*.sass',
        tasks: ['sass'],
        options: {
        livereload: {
            host: 'localhost',
            port: 9000,
            key: grunt.file.read('path/to/ssl.key'),
            cert: grunt.file.read('path/to/ssl.crt')
            // you can pass in any other options you'd like to the https server, as listed here: http://nodejs.org/api/tls.html#tls_tls_createserver_options_secureconnectionlistener
        }
        },
    },
    },
}


When working with core javascript functions functions like get element by id and get elements by classname , etc. are bound to find children on the element on which it is called.
So for example when we do something like document.forms[0].email.getElementsByTagName('input') this will find all the input elements inside the element with name email. 

We can also bind elevents like document.forms[0].onmouseover = function(event) {
    console.log(e.target)
}

We can do the same with document.forms[0].addEventListener("click", function(e){console.log('inside clicked')})

If we use submit or any event as name of the element in form then that event will not work because form.<Event Name> is going to give the element and not the event so for example if my submit button's name is submit then form.submit() will not work because form.submit is now an element's name not a function.


Html5 has formenctype attribute to override the enctype given in form 

application/x-www-form-urlencoded ----	Default. All characters are encoded before sent (spaces are converted to "+" symbols, and special characters are converted to ASCII HEX values). Example -- MyVariableOne=ValueOne&MyVariableTwo=ValueTwo

multipart/form-data ----	No characters are encoded. This value is required when you are using forms that have a file upload control

text/plain ----  Spaces are converted to "+" symbols, but no special characters are encoded


During Html5 Validation we get following properties on element getting validated inside javascript 
console.log(elem.validationMessage);
elem.setCustomValidity("custom validation message");
console.log(elem.checkValidity());
console.log(elem.validity);
console.log(elem.validationMessage);
console.log(elem.willValidate);

in addition to this we can have an event oninvalid on the element by which we can trap the invalidation event of an element if we dont want to do it on submit or press of any other button

elem.oninvalid = function(e) {
	console.log("%c On Invalid Event ", "background: black; color: darkgreen", e.target.validity)
}

There are two psuedo elements that we get with html 5 validation they are :valid and :invalid

If we want to insert html using css then we can use before and after psuedo elements to do that.
Remember property is necessary for these psuedo elements to work.

var elem               = document.createElement('div');
    elem.id            = 'notify';
    elem.style.display = 'none';
    form.appendChild(elem);

Filter method in jquery
Reduce the set of matched elements to those that match the selector or pass the function's test.

<ul>
  <li>list item 1</li>
  <li>list item 2</li>
  <li>list item 3</li>
  <li>list item 4</li>
  <li>list item 5</li>
  <li>list item 6</li>
</ul>
We can apply this method to the set of list items:

1
$( "li" ).filter( ":even" ).css( "background-color", "red" );
<ul>
  <li><strong>list</strong> item 1 - one strong tag</li>
  <li><strong>list</strong> item <strong>2</strong> -
    two <span>strong tags</span></li>
  <li>list item 3</li>
  <li>list item 4</li>
  <li>list item 5</li>
  <li>list item 6</li>
</ul>
We can select the list items, then filter them based on their contents:

$( "li" )
  .filter(function( index ) {
    return $( "strong", this ).length === 1;
  })
    .css( "background-color", "red" );

Css3 sibling selectors
ADJACENT SIBLING SELECTORS
p + p { font-size: smaller; } /* Selects all paragraphs that follow another paragraph */
#title + ul { margin-top: 0; } /* Selects an unordered list that directly follows the element with ID title */
GENERAL SIBLING SELECTORS
The general sibling combinator selector is very similar to the adjacent sibling combinator selector we just looked at. The difference is that that the element being selected doesn't need to immediately succeed the first element, but can appear anywhere after it.
If we use the same example structure as above, the last <p> element will be selected by p ~ p as well, because it is preceded by another <p> element, even though not directly.

oninput vs onchange event
oninput event occurs when the text content of an element is changed through the user interface.
onchange occurs when the selection, the checked state or the contents of an element have changed. In some cases, it only occurs when the element loses the focus. The onchange attribute can be used with: <input>, <select>, and <textarea>.


The DOM input event is fired synchronously when the value of an <input>, <select>, or <textarea> element is changed. For input elements with type=checkbox or type=radio, the input event should fire when a user toggles the control (via touch, mouse or keyboard) per the HTML5 specification, but historically, this has not been the case. Check compatibility, or attach to the change event instead for elements of these types.

Additionally, the input event fires on a contenteditable editor when its contents are changed. In this case, the event target is the editing host element. If there are two or more elements which have contenteditable as true, “editing host” is the nearest ancestor element whose parent isn’t editable. Similarly, it’s also fired on root element of designMode editors.


<input type="text" class="test"/>
<textarea></textarea>
<select>
  <option>1</option>
  <option>2</option>
  <option>3</option>
</select>
<pre></pre>

$(".test").on("input", function() {
	$("pre").prepend("\nOn Input.");
}).on("change", function () {
    $("pre").prepend("\nOn change.");
}).on("focus", function () {
    $("pre").prepend("\nOn focus.");
}).on("blur", function () {
    $("pre").prepend("\nOn blur.");
});

$("textarea").change(function() {
	$('pre').prepend("\n On change text area")
}).on("input", function() {
	$("pre").prepend("\nOn Input textarea.");
})

$("select").change(function() {
	$('pre').prepend("\n On change select")
}).on("input", function() {
	$("pre").prepend("\nOn Input Select.");
})

So for html5 custom validations we can check for elements validation as user types using input event.
But still following process is available.

There are two events we need to deal with. First, the invalid event which calls when the value of the input does not match the pattern. We’ll run the following within the invalid event:

input.addEventListener('invalid', function(event){
    event.preventDefault(); ----<<<<<<<---->>>>>>> ------<<<<<< This thing here prevents html5 error message popup from showing. So that we can show our own error messages.
    if ( ! event.target.validity.valid ) {
        elem.textContent   = 'Username should only contain lowercase letters e.g. john';
        elem.className     = 'error';
        elem.style.display = 'block';
 
        input.className    = 'invalid animated shake';
    }
});
Herein, with event.preventDefault();, we prevent the default behavior so that the default browser popup message does not appear. Instead, we are going to show our own through the new div element. We add the text message within the content, add a new class, error and show the message by setting the display to block.

For event bubbling 
A handler on a parent element can always get the details about where it actually happened.
The most deeply nested element that caused the event is called a target element, accessible as event.target.
Note the differences from this (=event.currentTarget):

event.target – is the “target” element that initiated the event, it doesn’t change through the bubbling process.
this – is the “current” element, the one that has a currently running handler on it.

event.stopImmediatePropagation()
If an element has multiple event handlers on a single event, then even if one of them stops the bubbling, the other ones still execute.

In other words, event.stopPropagation() stops the move upwards, but on the current element all other handlers will run.

To stop the bubbling and prevent handlers on the current element from running, there’s a method event.stopImmediatePropagation(). After it no other handlers execute.

To catch an event on the capturing phase, we need to set the 3rd argument of addEventListener to true.

There are two possible values for that optional last argument:

If it’s false (default), then the handler is set on the bubbling phase.
If it’s true, then the handler is set on the capturing phase.
Note that while formally there are 3 phases, the 2nd phase (“target phase”: the event reached the element) is not handled separately: handlers on both capturing and bubbling phases trigger at that phase.

<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Capturing: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Bubbling: ${elem.tagName}`));
  }
</script>

The code sets click handlers on every element in the document to see which ones are working.

If you click on <p>, then the sequence is:

HTML → BODY → FORM → DIV → P (capturing phase, the first listener), and then:
P → DIV → FORM → BODY → HTML (bubbling phase, the second listener).
Please note that P shows up two times: at the end of capturing and at the start of bubbling.

There’s a property event.eventPhase that tells us the number of the phase on which the event was caught. But it’s rarely used, because we usually know it in the handler.


Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.

var a = 100;
It is however important to remember that in the background, JavaScript is religiously declaring then initialising our variables.

As we mentioned before, all variable and function declarations are hoisted to the top of their scope. I should also add that variable declarations are processed before any code is executed.

However, in contrast, undeclared variables do not exist until code assigning them is executed. Therefore, assigning a value to an undeclared variable implicitly creates it as a global variable when the assignment is executed. This means that, all undeclared variables are global variables.


global variables
console.log(hoist); // Output: undefined

var hoist = 'The variable has been hoisted.';

We expected the result of the log to be: ReferenceError: hoist is not defined, but instead, its output is undefined.

Why has this happened?

This discovery brings us closer to wrangling our prey.

JavaScript has hoisted the variable declaration. This is what the code above looks like to the interpreter:

var hoist;

console.log(hoist); // Output: undefined
hoist = 'The variable has been hoisted.';

Function scoped variables
As we've seen above, variables within a global scope are hoisted to the top of the scope. Next, let's look at how function scoped variables are hoisted.

function hoist() {
  console.log(message);
  var message='Hoisting is all the rage!'
}

hoist();
Take an educated guess as to what our output might be.

If you guessed, undefined you're right. If you didn't, worry not, we'll soon get to the bottom of this.

This is how the interpreter views the above code:

function hoist() {
  var message;
  console.log(message);
  message='Hoisting is all the rage!'
}

hoist(); // Ouput: undefined

Strict Mode
Thanks to a utility of the es5 version of JavaScript known as strict-mode, we can be more careful about how we declare our variables. By enabling strict mode, we opt into a restricted variant of JavaScript that will not tolerate the usage of variables before they are declared.

Running our code in strict mode:

Eliminates some silent JavaScript errors by changing them to explicit throw errors which will be spit out by the interpreter.
Fixes mistakes that make it difficult for JavaScript engines to perform optimisations.
Prohibits some syntax likely to be defined in future versions of JavaScript.
We enable strict mode by prefacing our file or function with

'use strict';

// OR
"use strict";
Let's test it out.

'use strict';

console.log(hoist); // Output: ReferenceError: hoist is not defined
hoist = 'Hoisted'; 

const PI;
console.log(PI); // Ouput: SyntaxError: Missing initializer in const declaration
PI=3.142;
Therefore, a constant variable must be both declared and initialised before use.


Function declarations
These are of the following form and are hoisted completely to the top. Now, we can understand why JavaScript enable us to invoke a function seemingly before declaring it.

hoisted(); // Output: "This function has been hoisted."

function hoisted() {
  console.log('This function has been hoisted.');
};

Function expressions
Function expressions, however are not hoisted.

expression(); //Output: "TypeError: expression is not a function

var expression = function() {
  console.log('Will this work?');
};


function a()                                                
{
    var x = 10;

    function x() {
        return 20;
    }

    return x;
}

above will be hoisted like
function a() {
  var x;
  function x() { // this function is assigned to variable indicator "x"
    return 20;
  }
  x = 10; // this overrides the variable indicator "x"
  return x;
}

so variable declaration goes first then function declaration then variable assignment.


javascript ajax for ie 6 or lesser versions
if (window.XMLHttpRequest) {
    //Firefox, Opera, IE7, and other browsers will use the native object
    var request = new XMLHttpRequest();
} else {
    //IE 5 and 6 will use the ActiveX control
    var request = new ActiveXObject("Microsoft.XMLHTTP");
}


req.open( "GET", 'boo.txt', false );
the third parameter is for making the request to synchronous or asynchronous.

req.onreadystatechange = function()
{
    if( req.readyState == 4 && req.status == 200 )
    {
        document.write( req.responseText );
    }
}

0 – The default value when the XMLHttpRequest object is created.
1 – The open() method has been called.
2 – The send() method has been called.
3 – Some data has been retrieved, but the request isn’t finished.
4 – All data has been retrieved and the request is finished.

false in open makes it synchronous default value is true which is asynchronous.

XMLHttpRequest {onreadystatechange: null, readyState: 0, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …}
onabort : null
onerror : null 
onload : null
onloadend : null
onloadstart : null
onprogress : null
onreadystatechange : null
ontimeout : null
readyState : 0
response : ""
responseText : ""
responseType : ""
responseURL : ""
responseXML : null
status : 0
statusText : ""
timeout : 0
upload :
XMLHttpRequestUpload {onloadstart: null, onprogress: null, onabort: null, onerror: null, onload: null, …}
withCredentials : false
__proto__ : XMLHttpRequest


// not all the events will work in synchronous calls but for asynchronous calls all the events will work.

for synchronous calls progress events was received only in onloadend event onloadstart evet didnot fire at all in synchronous call.
Timeout is zero in synchronous call and cannot be changed.

First on progress event for asynchronous calls is received in onLoadStart with lengthComputable: false and loaded:0 and readyState is 2
Second on progress event for asynchronous calls is received in onProgress with lengthComputable: true and loaded:<full length of the object received> and readyState is 3
Third on progress event for asynchronous calls is received in onLoadEnd with lengthComputable: true and loaded:<full length of the object received> and readyState is 4

So xhr.onProgress event gets fired only when complete object is received

for aborting the ajax request 
var xhr = new XMLHttpRequest(),
    method = "GET",
    url = "https://developer.mozilla.org/";
xhr.open(method,url,true);

xhr.send();

xhr.abort();

.ajaxStop() ->>> Register a handler to be called when all Ajax requests have completed. This is an Ajax Event.

Aborting jquery ajax request.
var calculationRequest = null;

function PerformAbortableCalculation()
{
        if(calculationRequest != null)
                calculationRequest.abort();
        calculationRequest = $.get("/tests/calc.php", function(data, textStatus)
        {
                alert(data);
        });
}


req.responseType is supposed to allow only the response type set in this variable as a response from server if response is different the this value is null.
responseText is based on responseType value if responseType is somthing other than text or '' then the responseText is empty.
responseText is string representation of response.
so if responseType is json then responseText is empty.

In jquery ajax responseType id dataType. dataType is you telling jQuery what kind of response to expect.

Accept header tells the server about the type of content it is expecting 
Content-type tells the server about the type of request it is sending.

dataType and accpets must mapped together.

in order to get the response header we need to use getResponseHeader('header name') method.
in order to get all the response headers we need to use getAllResponseHeaders() method.

To set request headers in ajax we can use two approaches by setting headers: {} property on ajax call or by xhr.setRequestHeader in beforeSend


The same-origin policy controls interactions between two different origins, such as when you use XMLHttpRequest or an <img> element. These interactions are typically placed in three categories:

Cross-origin writes are typically allowed. Examples are links, redirects and form submissions. Certain rarely used HTTP requests require preflight.
Cross-origin embedding is typically allowed. Examples are listed below.
Cross-origin reads are typically not allowed, but read access is often leaked by embedding. For example you can read the width and height of an embedded image, the actions of an embedded script, or the availability of an embedded resource.
Here are some examples of resources which may be embedded cross-origin:

JavaScript with <script src="..."></script>. Error messages for syntax errors are only available for same-origin scripts.
CSS with <link rel="stylesheet" href="...">. Due to the relaxed syntax rules of CSS, cross-origin CSS requires a correct Content-Type header. [...]

JSONP is nothing but json with padding. In order to accomplish this we make use of the fact that script tags are not a part of cross-origin restrictions .
So we can call any urls to read stuff using a callback query parameter in request url. The service endpoint responsding to this must give back the output as passing the json argument to that callback in url.
Example
function response(resposne) {
  return response;
}
http://www.abc.com/?callback=callMe
service enpoint should respond with 
callMe({json object values})

datatype:script or .getScript() method work the same they are used to read the resonse as javascript and return it as string.
$.ajax({
  url: url,
  dataType: "script",
  success: success
}); this is equivalent to 
$.getScript( "ajax/test.js", function( data, textStatus, jqxhr ) {
  console.log( data ); // Data returned
  console.log( textStatus ); // Success
  console.log( jqxhr.status ); // 200
  console.log( "Load was performed." );
});

when datatype is jsonp the default callback is supplie in the url if you want to overrite it then we can give an option like 
datatype: jsonp,
jsonp:function(){}

defining jquery function 
$.fn.myfunction = function() {
      alert('hello world');
      return this;
};

when calling function this will give the object on which it is called
so if we cann myfunction() then this will be window because its called on window.myfunction 

global (default: true)
Type: Boolean
Whether to trigger global Ajax event handlers for this request. The default is true. Set to false to prevent the global handlers like ajaxStart or ajaxStop from being triggered. This can be used to control various Ajax Events.

So if we call .json file in ajax jquery we dont get success method executed. The error in this case is unknow but if we use the same request for local server having same origin then it works fine.

Setting xhr.withCredentials = true inside beforeSend doesent work 
instead we need to use xhrFields key 
xhrFields: {
  withCredentials: true
}
withCredentials field need to be set on both server and ui side in order to start setting cookies from server on UI.
Cookies get set if requests are between same domains.

document.cookie are sent to the servers in ajax request when the requests are in same domain but local cookies dont get send to server unless they are set using Set-Cookie header.

Although CORS allows cross-origin requests, the cookies are still subject to the browser's same-origin policy, which means only pages from the same origin can read/write the cookie. withCredentials only means that any cookies set by the remote host are sent to that remote host. You will have to set the cookie from the remote server by using the Set-Cookie header.


upload: XMLHttpRequestUpload
onabort: null
onerror: null
onload: null
onloadend: null
onloadstart: null
onprogress: null
ontimeout: null

when events on upload are bound then events on core chr object wont work or we can say if both core xhr events and upload events are bound then upload events will take precedence over core events exmaple if xhr.onloadstart and xhr.upload.onloadstart are bound at the same time the xhr.upload.onloadstart will be executed.
On readystate change will be executed on xhr object only.
onload gets executed after the ajax call is completed sucessfully but before onloadEnd is called its available on both xhr and xhr.upload

ProgressEvent {isTrusted: true, lengthComputable: true, loaded: 699, total: 699, type: "load", …}
bubbles:false
cancelBubble:false
cancelable:false
composed:false
currentTarget:XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 4294967295, withCredentials: false, upload: XMLHttpRequestUpload, …}
defaultPrevented:false
eventPhase:0
isTrusted:true
lengthComputable:true
loaded:699
path:[]
returnValue:true
srcElement:XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 4294967295, withCredentials: false, upload: XMLHttpRequestUpload, …}
target:XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 4294967295, withCredentials: false, upload: XMLHttpRequestUpload, …}
timeStamp:2793.985
total:699
type:"load"

we get this object in 4 places onloadstart, onprogress, onload, onloadend.
We need to consider 3 things in this object
lengthComputable: true or false
loaded
total

lengthComputable - a read-only (Boolean) property indicating if the resource concerned by the ProgressEvent has a length that can be calculated
total - a read-only (Unsigned Long) property representing the total amount of work that the underlying process is in the progress of performing
loaded - a read-only (Unsigned Long) property representing the amount of work already performed by the underlying process

'responseXML' property from 'XMLHttpRequest': The value is only accessible if the object's 'responseType' is '' or 'document'

There are two progress events in a XmlHttpRequest object:

The response progress (XmlHttpRequest.onprogress)
This is when the browser is downloading the data from the server.

The request progress (XmlHttpRequest.upload.onprogress)
This is when the browser is sending the data to the server (including POST parameters, cookies, and files)

In your code you are using the response progress event, but what you need is the request progress event. This is how you do it:

$.ajax({
    async: true,
    contentType: file.type,
    data: file,
    dataType: 'xml',
    processData: false,
    success: function(xml){
        // Do stuff with the returned xml
    },
    type: 'post',
    url: '/fileuploader/' + file.name,
    xhr: function(){
        // get the native XmlHttpRequest object
        var xhr = $.ajaxSettings.xhr() ;
        // set the onprogress event handler
        xhr.upload.onprogress = function(evt){ console.log('progress', evt.loaded/evt.total*100) } ;
        // set the onload event handler
        xhr.upload.onload = function(){ console.log('DONE!') } ;
        // return the customized object
        return xhr ;
    }
});

onload event can be used as combination of onreadystate change and readystate = 4

.ajaxStart(): Register a handler to be called when the first Ajax request begins. This is an Ajax Event.

Note: Global callback functions should be set with their respective global Ajax event handler methods—.ajaxStart(), .ajaxStop(), .ajaxComplete(), .ajaxError(), .ajaxSuccess(), .ajaxSend()—rather than within the options object for $.ajaxSetup().

URL provides methods to generate url for blobs. So that we can directly show it in UI and also pass it to the api that accepts it.


WorkerGlobalScope interface is an interface representing scope of any worker.
Workers have no browsing context. This scope contains information usually conveyed by window object.
in this case event handlers, the console or the associated WorkerNavigator object.
WindowNavigator is just representation of window.navigator object.

This interface is usually specialized by each worker type:
DedicatedWorkerGlobalScope for dedicated workers, 
SharedWorkerGlobalScope for shared workers, and 
ServiceWorkerGlobalScope for ServiceWorker. 
The self property returns the specialized scope for each context.


Web workers are of three types 
Dedicated
Shared
Service

When main js starts a worker it spawns a new thread which runs in background without affecting other things.
It can use ajax calls aswell.
But workers don't have any browsing context so inorder to use the global context object window we use self.
	
Web Workers don't have a window object.
To access global state, use self instead, code that will work on both the main thread and the worker thread.
But note that you still won't be able to access or manipulate the parent DOM (e.g. get window.jQuery via self.jQuery).
While the main thread window self points to the Window object, in worker threads self points to a separate WorkerGlobalScope object.

window object is not equal to self object its just a reference to window object and provides the few methods available on window object such as navigator, location, etc. But setting a value in window object and then trying to access it in self is not going to work.

Shared workers can be accessed by multiple scripts and not just one script as in case of dedicated workers.
These scripts can be anywhere inside a different window or frame or script.

Inorder to comunicate in shared workers we need to use port object.
The port connection needs to be started either implicitly by use of the onmessage event handler or explicitly with the start() method before any messages can be posted

When using the start() method to open the port connection, it needs to be called from both the parent thread and the worker thread if two-way communication is needed.

myWorker.port.start();  // called in parent thread
port.start();  // called in worker thread, assuming the port variable references a port

myWorker.port.postMessage([squareNumber.value,squareNumber.value]);

onconnect = function(e) {
  var port = e.ports[0];

  port.onmessage = function(e) {
    var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
    port.postMessage(workerResult);
  }
}

we use an onconnect handler to fire code when a connection to the port happens (i.e. when the onmessage event handler in the parent thread is setup, or when the start() method is explicitly called in the parent thread).

self is equivalent to window in worker file but gives WorkerGlobalScope object and not actual global scope object which in case of Dedicated worker is DedicatedWorkerGlobalScope and in case of shared SharedWorkerGlobalScope.

Service workers work only with https requests and async requests so localstorage and synchronous XHR are not allow.

Service worker scopes are restricted to both the location of service worker file and the current url.
If service worker file is inside a directory such as src then it will be restricted to track the fetching of
files inside that directory.

If the current page url or request url is different than the directory of service worker and we use scope like {scope: './'} then error is thown that the request we are trying to make is out of scope of service worker and then inorder to resolve this we need to move the service worker script to another location to match the request url or we need to add Service-Worker-Allowed: true or we can omit the scope argument.

Install event allows to registers specific resources for worker such as caches.
while install is happening we get one more event
event.waitUntill to wait untill the installation process is completed and install stage in resolved.
if install event is taking too long the we can even skip it by self.skipWaiting()

After the install is finished and is waiting for the clients using other service workers to be closed.

Activate state begins when there are no workers left on which clients are working. This stage can be used to clean up anything that was being used by other clients and workers and now after they have stopped they are no more requied.

Activate events can also be extended and be waited for to be finished using same methods as above in install phase
event.waitUntill
and self.clients.claim() --- start handling and controlling all open clients without reloading them. 

So while serving script files from servers that have htaccess support we can set the response headers in htaccess file like 
Header add Custom-Header "parameter=value"
request will be 
GET / HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
DNT: 1
Connection: keep-alive
Cache-Control: max-age=0

.to which the server responded with the following headers:

HTTP/1.1 200 OK
Server: nginx
Date: Mon, 01 Aug 2016 17:58:14 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
X-Powered-By: PHP/5.6.24, PleskLin
strict-transport-security: max-age=63072000; includeSubDomains; preload
Cache-Control: no-cache, no-store, must-revalidate
Pragma: no-cache
Expires: 0
Custom-Header: parameter=value
Content-Language: en

there i can also check if file requested is a js file or not

Fetch API
There are new objects like Request, response and fetch().
Fetch is used to fetch any resource like a normal ajax call . It takes as an argument the request object or url string and returns back a promise object which can be clubbed with then and catch methods.
Then method receives Response object.

Promise<Response> fetch(input[, init]);
Parameters
input
This defines the resource that you wish to fetch. This can either be:
A USVString containing the direct URL of the resource you want to fetch. Some browsers accept blob: and data: as schemes.
A Request object.
init Optional
An options object containing any custom settings that you want to apply to the request. The possible options are:
method: The request method, e.g., GET, POST.
headers: Any headers you want to add to your request, contained within a Headers object or an object literal with ByteString values.
body: Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
mode: The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
credentials: The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided. Starting with Chrome 50, this property also takes a FederatedCredential instance or a PasswordCredential instance.
cache: The cache mode you want to use for the request: default, no-store, reload, no-cache, force-cache, or only-if-cached.
redirect: The redirect mode to use: follow (automatically follow redirects), error (abort with an error if a redirect occurs), or manual (handle redirects manually). In Chrome the default was follow before Chrome 47 and manual starting with Chrome 47.
referrer: A USVString specifying no-referrer, client, or a URL. The default is client.
referrerPolicy: Specifies the value of the referer HTTP header. May be one of no-referrer, no-referrer-when-downgrade, origin, origin-when-cross-origin, unsafe-url.
integrity: Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).
keepalive: The keepalive option can be used to allow the request to outlive the page. Fetch with the keepalive flag is a replacement for the Navigator.sendBeacon() API. 
signal: An AbortSignal object instance; allows you to communicate with a fetch request and abort it if desired via an AbortController.

Request object is for preparing and creating a request object which can be passed to fetch.
It takes input and init as arguments.
Input can be url or another request object.
Init can be an options object with method, headers, body which can be Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object, mode which can be cors, no-cors, same-origin, or navigate, credentials, etc

var myRequest = new Request(input, init);
Parameters
input
Defines the resource that you wish to fetch. This can either be:
A USVString containing the direct URL of the resource you want to fetch.
A Request object, effectively creating a copy. Note the following behavioural updates to retain security while making the constructor less likely to throw exceptions:
If this object exists on another origin to the constructor call, the Request.referrer is stripped out.
If this object has a Request.mode of navigate, the mode value is converted to same-origin.
init Optional
An options object containing any custom settings that you want to apply to the request. The possible options are:
method: The request method, e.g., GET, POST.
headers: Any headers you want to add to your request, contained within a Headers object or an object literal with ByteString values.
body: Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object. Note that a request using the GET or HEAD method cannot have a body.
mode: The mode you want to use for the request, e.g., cors, no-cors, same-origin, or navigate. The default is cors. In Chrome the default is no-cors before Chrome 47 and same-origin starting with Chrome 47.
credentials: The request credentials you want to use for the request: omit, same-origin, or include. The default is omit. In Chrome the default is same-origin before Chrome 47 and include starting with Chrome 47.
cache: The cache mode you want to use for the request.
redirect: The redirect mode to use: follow, error, or manual. In Chrome the default is manual before Chrome 47 and follow starting with Chrome 47.
referrer: A USVString specifying no-referrer, client, or a URL. The default is client.
integrity: Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).


Response is the object for preparing and creating a response along with body and headers. which can then be passed to other calling methods.

It takes two arguments body and init as options.
BOdy can be one of the following
Blob
BufferSource
FormData
ReadableStream
URLSearchParams
USVString

init takes following options
status,
statusText,
headers

headers in both request and response are an object of Headers which has some methods like get getall append delete has etc

File Blob and Filereader

File is an extension on Blob object. Its specific use is to create a reference object for a file which will give some meta properties of file such as size, last modified, name , type , etc.

File does not define any methods of its own. It inherits them from blob.

File constructor takes three arguments 
An Array of ArrayBuffer, ArrayBufferView, Blob, or DOMString objects — or a mix of any such objects. This is the file content encoded as UTF-8.
name of file,
options which include 
type and lastModified
var file = new File(["foo"], "foo.txt", {
  type: "text/plain",
});


Blob is the representation of file like objects in raw immutable form.
We can construct blob object from other non blob objects using Blob() constructor
Blob constructor takes two arguments
An Array of ArrayBuffer, ArrayBufferView, Blob, or DOMString objects — or a mix of any such objects. This is the file content encoded as UTF-8.
options which contains type -> the mine type of the file 
endings: which defines how the line breaks in the given data are supposed to be treated in new raw file. The values are native which converts all breaks into os specific breaks. Transparent which keeps the breaks as it is.

var aFileParts = ['<a id="a"><b id="b">hey!</b></a>']; // an array consisting of a single DOMString
var oMyBlob = new Blob(aFileParts, {type : 'text/html'}); // the blob

New blob can be constructed from another blob object using slice method
Slice is browser specific method which means for different browsers we have different variants of slice.

var blob = instanceOfBlob.slice([start [, end [, contentType]]]);

To obtain a Blob object for a file on the user's file system we use File object.


The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read.

Properties
FileReader.error Read only
A DOMException representing the error that occurred while reading the file.
FileReader.readyState Read only
A number indicating the state of the FileReader. This is one of the following:
EMPTY	0	No data has been loaded yet.
LOADING	1	Data is currently being loaded.
DONE	2	The entire read request has been completed.
FileReader.result Read only
The file's contents. This property is only valid after the read operation is complete, and the format of the data depends on which of the methods was used to initiate the read operation.

Event handlers
FileReader.onabort
A handler for the abort event. This event is triggered each time the reading operation is aborted.
FileReader.onerror
A handler for the error event. This event is triggered each time the reading operation encounter an error.
FileReader.onload
A handler for the load event. This event is triggered each time the reading operation is successfully completed.
FileReader.onloadstart
A handler for the loadstart event. This event is triggered each time the reading is starting.
FileReader.onloadend
A handler for the loadend event. This event is triggered each time the reading operation is completed (either in success or failure).
FileReader.onprogress
A handler for the progress event. This event is triggered while reading a Blob content.


Methods
FileReader.abort()
Aborts the read operation. Upon return, the readyState will be DONE.
FileReader.readAsArrayBuffer()
Starts reading the contents of the specified Blob, once finished, the result attribute contains an ArrayBuffer representing the file's data.
FileReader.readAsBinaryString() 
Starts reading the contents of the specified Blob, once finished, the result attribute contains the raw binary data from the file as a string.
FileReader.readAsDataURL()
Starts reading the contents of the specified Blob, once finished, the result attribute contains a data: URL representing the file's data.
FileReader.readAsText()
Starts reading the contents of the specified Blob, once finished, the result attribute contains the contents of the file as a text string.

FileReader object and File can be used with File , blob or even with FileList object from input elements.

FileList ->>> FileList is the object which represents the list of files in given file input element.
var inputFile = document.getElementsByName("file").item(0);
so inputFile.files will give FileList

createDocumentFragment doesnot modify the actual untill its added to html . It creates a virtual dom or fragment and we keep on doing modification to that but not to actual dom.
createElement transparently in the backend keep manipulating the DOM though we not see it in the page but it actually modifies the dom.

File and Blobs cannot read file on local machine unless they are uploaded.

Script type
module: HTML5 For HTML5-compliant browsers the code is treated as a JavaScript module. The processing of the script contents is not affected by the charset and defer attributes.

Module types js are automatically 'use-strict'
Module types can use import and exports.
Module types behave like defer by default.
Defer by default
<!-- This script will execute after… -->
<script type="module" src="1.js"></script>

<!-- …this script… -->
<script src="2.js"></script>

<!-- …but before this script. -->
<script defer src="3.js"></script>

nomodule 
This Boolean attribute is set to indicate that the script should not be executed in browsers that support ES6 modules — in effect, this can be used to serve fallback scripts to older browsers that do not support modular JavaScript code.

Async works on external & inline modules
<!-- This executes as soon as its imports have fetched -->
<script async type="module">
  import {addTextToBody} from './utils.js';

  addTextToBody('Inline module executed.');
</script>

<!-- This executes as soon as it & its imports have fetched -->
<script async type="module" src="1.js"></script>


<!-- 1.js only executes once -->
Modules only execute once
<script type="module" src="1.js"></script>
<script type="module" src="1.js"></script>
<script type="module">
  import "./1.js";
</script>

<!-- Whereas normal scripts execute multiple times -->
<script src="2.js"></script>
<script src="2.js"></script>

Always CORS
<!-- This will not execute, as it fails a CORS check -->
<script type="module" src="https://….now.sh/no-cors"></script>

<!-- This will not execute, as one of its imports fails a CORS check -->
<script type="module">
  import 'https://….now.sh/no-cors';

  addTextToBody("This will not execute.");
</script>

<!-- This will execute as it passes CORS checks -->
<script type="module" src="https://….now.sh/cors"></script>

No credentials
<!-- Fetched with credentials (cookies etc) -->
<script src="1.js"></script>

<!-- Fetched without credentials -->
<script type="module" src="1.js"></script>

<!-- Fetched with credentials -->
<script type="module" crossorigin src="1.js?"></script>

<!-- Fetched without credentials -->
<script type="module" crossorigin src="https://other-origin/1.js"></script>

<!-- Fetched with credentials-->
<script type="module" crossorigin="use-credentials" src="https://other-origin/1.js?"></script>

In HTML5, some HTML elements which provide support for CORS, such as <img>, <video> or <script>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data. These attributes are enumerated, and have the following possible values:

Keyword	Description
anonymous	CORS requests for this element will not have the credentials flag set.
use-credentials	CORS requests for this element will have the credentials flag set; this means the request will provide credentials.
By default (that is, when the attribute is not specified), CORS is not used at all. The "anonymous" keyword means that there will be no exchange of user credentials via cookies, client-side SSL certificates or HTTP authentication

When you use the crossorigin attribute it sets the "use-URL-credentials" flag and maps anonymous to "same-origin" and use-credentails to "include" for the crendentials mode. If you omit the crossorigin attribute, "use-URL-credentials" is unset and, the default for credentials mode is assumed, which is omit.

You can add credentials to a same-origin module by including the crossorigin attribute (which seems a bit weird to me, and I've questioned this in the spec). If you want to send credentials to other origins too, use crossorigin="use-credentials".



using module we can use import and export but for other features we dont need to use module. Normal text/javascript will work.

nomodule works only with text/javascript. If given with tyep module its omitted and script still executes.

Error: Failed to load http://sysblog.local:8080/index.php: Response for preflight is invalid (redirect)
indicates that the page requested is redirecting the user somewhere.

jqXHR is superset of xhr which is actual representation of XMLHttpRequest object.

Access-Control-Allow-Origin
Access-Control-Allow-Credentials
these are headers which are required to be present in both OPTIONS request and GET request.

it is contentType in ajax call that defines enctype of form
using application/x-www-form-urlencoded, multipart/form-data, or text/plain values with contentType will mimic the behaviour of actual form submission with enctype as these values.

crossDomain jquery option -> If you wish to force a crossDomain request (such as JSONP) on the same domain, set the value of crossDomain to true 

converters (default: {"* text": window.String, "text html": true, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML})
Type: PlainObject
An object containing dataType-to-dataType converters. Each converter's value is a function that returns the transformed value of the response. 

Default value of content-type header (in ajax or form) or enctype (in form) is application/x-www-form-urlencoded.

if data is sent as application/x-www-form-urlencoded it is received in both $_POST and php://input stream ( as name=kushagra&age=38).

processData By default, data passed in to the data option as an object (technically, anything other than a string) will be processed and transformed into a query string, fitting to the default content-type "application/x-www-form-urlencoded".  If you want to send a DOMDocument, or other non-processed data, set this option to false.

Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding:gzip, deflate
Accept-Language:en-US,en;q=0.9,fr;q=0.8
Cache-Control:max-age=0
Connection:keep-alive
Content-Length:365
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrosnbEUsHNClsQYZ
Cookie:PHPSESSID=m9tpj4fnn5n7uh48s939n7ri32
DNT:1
Host:sysblog.local:8080
Origin:http://localhost:9000
Referer:http://localhost:9000/
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36

------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="email"

karizmatic.kay@gmail.com
------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="firstname"

Kushagra
------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="lastname"

Mishra
------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="ufile"; filename="adhaar.png"
Content-Type: image/png


------WebKitFormBoundary76JWxVOm9dQTKlbs--

multipart/formdata 
With this method of transmitting name/value pairs, each pair is represented as a "part" in a MIME message (as described by other answers). Parts are separated by a particular string boundary (chosen specifically so that this boundary string does not occur in any of the "value" payloads). Each part has its own set of MIME headers like Content-Type, and particularly Content-Disposition, which can give each part its "name." The value piece of each name/value pair is the payload of each part of the MIME message. The MIME spec gives us more options when representing the value payload -- we can choose a more efficient encoding of binary data to save bandwidth (e.g. base 64 or even raw binary).

So as we can see the multipart/formdata request uses boundries for every key/value pair which creates its own mime-type . So very mime has its own set of headers such as content type and content Disposition

This type of behaviour cannot be mimiced with normal ajax flow hence we need Formdata otherwise it prepares a query string similar to application/x-www-form-urlencoded with & and %20.

Content-Type can be anything event application/kushagra and whatever we pass as a data for post method 
it will be converted to application/x-www-form-urlencoded format with & and %20 or whatever encoding is required.

If enctype is unsupported (even if it is application/json) then it will automatically convert to application/x-www-form-urlencoded such as in case of application/kushagra.

text/plain enctype sends request payload and not form data like in normal application/x-www-form-urlencoded request. Hence it can only be retrieved from php://input.In this case only filename will go with the post request and not actual file object.
email=karizmatic.kay@gmail.com
firstname=Kushagra
lastname=Mishra
ufile=adhaar.png

but if used with ajax calls then the request payload goes as in application/x-www-form-urlencoded.
name=kushagra&age=38

Whatever w3school says about text/plain enctype is wrong no encryption is performed even + is not used

In XMLHttpRequest content type with value application/x-www-form-urlencoded, multipart/formdata, text/plain if the actual content is not in required format the value gets converted to application/x-www-form-urlencoded format that is with & and %20 etc.
So if json value or anyother value other than normal text is supplied with text/plain or json value, anyother value which is not multipart request with boundary is supplied with multipart/formdata or any other content-type then the payload is converted to application/x-www-form-urlencoded.

Blob can set its content-type and hence we can see the use of other property Content-Type in multipart request which belongs to only a specific mime subpart.

"------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="username"

Groucho
------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="accountnum"

123456
------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="ufile"

undefined
------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="webmasterfile"; filename="blob"
Content-Type: text/xml

<a id="a"><b id="b">hey!</b></a>
------WebKitFormBoundaryXlk8RvQzJKAhmGr4--
"

when sending formdata with file through ajax we need to skip setting content-type header because for multipart requests we need to set boundary value also with multipart/formdata which when setting manually can't be set so we need to just let it set automatically which will add boundary value. Content-Type:multipart/form-data; boundary=----WebKitFormBoundarybkqwsY2nEFys9wg5

If no content-type is set and json or anyother unsupported format like text is passed then in core XmlHttpRequest it is passed as raw data with text/plain as content-type.

Which in case of jquery ajax would have been set to application/x-www-form-urlencoded and data converted accordingly.

.hover() is jquery event it binds tagNameo events mouseenter and mouseleave.

For upload both xhr.progressEvent and xhr.upload.progressEvent work in which xhr.progressEvent does not give the total amount to be uploaded, it only gives the amount upload till now but xhr.upload.progressEvent will give both the uploaded aswell as total to be uploaded.
Upload process is not completed untill xhr.progressEvent is finished and xhr.onload event is fired or xhr.readyState is 4. 

for downloading using jquery ajax we need to setup responseType to blob , dataType: blob doesnot work.

The response progress (XmlHttpRequest.onprogress)
This is when the browser is downloading the data from the server.

The request progress (XmlHttpRequest.upload.onprogress)
This is when the browser is sending the data to the server (including POST parameters, cookies, and files)

progressevent on ajax should be bound using xhrFiles anyother way will not work
xhrFields: {
    withCredentials: true,
    responseType: 'blob',
    onprogress: function(e) {console.log("%c On Progress ", "background: darkgreen; color: #ffffff", e);}
},

We can het XmlHttpRequest object in jquery ajax using $.ajaxSettings.xhr();
Where as $.ajaxSettings gives the json object of settings done by $.ajaxSetup

accepts:{*: "*/*", text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript", …}
async:true
contentType:"application/x-www-form-urlencoded; charset=UTF-8"
contents:{xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/, script: /\b(?:java|ecma)script\b/}
converters:{* text: ƒ, text html: true, text json: ƒ, text xml: ƒ, text script: ƒ}
flatOptions:{url: true, context: true}
global:true
isLocal:false
jsonp:"callback"
jsonpCallback:ƒ ()
processData:true
responseFields:{xml: "responseXML", text: "responseText", json: "responseJSON"}
type:"GET"
url:"http://localhost:9000/"
xhr:ƒ ()


xhr: function() {} is the callback used to prepare XmlHttpRequest object and hence here we can bind upload progress event 
xhr: function() {
    var myXhr = $.ajaxSettings.xhr();
    myXhr.upload.onprogress = function(e) {console.log("%c On Progress Upload ", "background: orange; color: #ffffff", e);}
    return myXhr;
},

delete operator removes property from object.


Web applications can allow or disallow other webapplication to incude their pages in an iframe by using following header
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM https://example.com/

inorder to add headers in htaccess request we need to enable mod_headers directive in apache.

Chrome and Safari don't support X-Frame-Options
so for that we need to use Content-Security-Policy
Syntax
Content-Security-Policy: <policy-directive>; <policy-directive>

This response header tell the browser that load different sections according to the given value in the header such as
default-src
Serves as a fallback for the other fetch directives.
font-src
Specifies valid sources for fonts loaded using @font-face.
frame-src
Specifies valid sources for nested browsing contexts loading using elements such as <frame> and <iframe>.
img-src
Specifies valid sources of images and favicons.
manifest-src
Specifies valid sources of application manifest files.
media-src
Specifies valid sources for loading media using the <audio> , <video> and <track> elements.
object-src
Specifies valid sources for the <object>, <embed>, and <applet> elements.
script-src
Specifies valid sources for JavaScript.
style-src
Specifies valid sources for stylesheets.
worker-src
Specifies valid sources for Worker, SharedWorker, or ServiceWorker scripts.

It can be used as response header as well as a meta tag 
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
with unsafe inline we can allow the use of inline <script> tags , javascript: and also inline event handlers which otherwise wont be allowed.

Content-Security-Policy actually gives a white list of src to browser to load resources from these src's only.

From the DOM iframe element, scripts can get access to the window object of the included HTML page via the contentWindow property. The contentDocument property refers to the document element inside the iframe (this is equivalent to contentWindow.document), but is not supported by Internet Explorer versions before IE8.

We cannot access the content of another window such as iframe window(iframe.contentWindow) or new window from window.open or anyother window from different domain using javascript. Hence in order to communicate between different windows from different origins we make use of Message event and postMessage method on window object.


window.history.back();
window.history.forward();
window.history.go(-1);
window.history.go(1);
var numberOfEntries = window.history.length;

onpopstate is an event handler for the popstate event on the window.

A popstate event is dispatched to the window each time the active history entry changes between two history entries for the same document. If the activated history entry was created by a call to history.pushState(), or was affected by a call to history.replaceState(), the popstate event's state property contains a copy of the history entry's state object.

Note: calling history.pushState() or history.replaceState() won't trigger a popstate event. The popstate event is only triggered by performing a browser action, such as clicking on the back button (or calling history.back() in JavaScript), when navigating between two history entries for the same document.

window.onpopstate = function(event) {
  alert("location: " + document.location + ", state: " + JSON.stringify(event.state));
};

history.pushState({page: 1}, "title 1", "?page=1");
history.pushState({page: 2}, "title 2", "?page=2");
history.replaceState({page: 3}, "title 3", "?page=3");
history.back(); // alerts "location: http://example.com/example.html?page=1, state: {"page":1}"
history.back(); // alerts "location: http://example.com/example.html, state: null
history.go(2);  // alerts "location: http://example.com/example.html?page=3, state: {"page":3}

Popstate event 
PopStateEvent {isTrusted: true, state: {…}, type: "popstate", target: Window, currentTarget: Window, …}
bubbles:false
cancelBubble:false
cancelable:true
composed:false
currentTarget:Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
defaultPrevented:false
eventPhase:0
isTrusted:true
path:[Window]
returnValue:true
srcElement:Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
state:{foo: "bar"}
target:Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
timeStamp:16264.45
type:"popstate" 


Example of pushState() method
Suppose http://mozilla.org/foo.html executes the following JavaScript:

var stateObj = { foo: "bar" };
history.pushState(stateObj, "page 2", "bar.html");

The pushState() method
pushState() takes three parameters: a state object, a title (which is currently ignored), and (optionally) a URL. Let's examine each of these three parameters in more detail:

state object — The state object is a JavaScript object which is associated with the new history entry created by pushState(). Whenever the user navigates to the new state, a popstate event is fired, and the state property of the event contains a copy of the history entry's state object.

The state object can be anything that can be serialized. Because Firefox saves state objects to the user's disk so they can be restored after the user restarts the browser, we impose a size limit of 640k characters on the serialized representation of a state object. If you pass a state object whose serialized representation is larger than this to pushState(), the method will throw an exception. If you need more space than this, you're encouraged to use sessionStorage and/or localStorage.

title — Firefox currently ignores this parameter, although it may use it in the future. Passing the empty string here should be safe against future changes to the method. Alternatively, you could pass a short title for the state to which you're moving.

URL — The new history entry's URL is given by this parameter. Note that the browser won't attempt to load this URL after a call to pushState(), but it might attempt to load the URL later, for instance after the user restarts the browser. The new URL does not need to be absolute; if it's relative, it's resolved relative to the current URL. The new URL must be of the same origin as the current URL; otherwise, pushState() will throw an exception. This parameter is optional; if it isn't specified, it's set to the document's current URL.

hashchange event is fired when location's href changes.

pushstate changes the current url and creates a new state and pushes it to the history so that the url of the page containing the pushstate script is still in history. and hence when we click back button we can get to that url but in case of replaceState the url of the page that included replaceState script will be removed from the history and replaced the new state defined by replaceState.

Jquery's `on` method helps to bind events based on when they bubble or when event occurs directly to the objects that are present at time of event attaching.
so 
When doing something like 
$(window).on('load', function(e) {
    console.log("Body Load Done", e)
})
load event is directly bound to window object which is present at all times.

but when doing something like 
$(window).on('load','body', function(e) {
    console.log("Body Load Done", e)
})
load event callback doesnot gets called because above is delegated way of binding events when they bubble up to the element to which the event is actully bound, in this case window.

Delegation helps us to bind events with elements which are of present at time time of binding but will be available sometime later.

So above call is trying to bind an event on body inside a window element , because body is not available in start or at the time when this event will be bound hence we are using window to bind the event so that when body is avaiable, any event that occurs on body will propogate up till window and there we catch the event on window binding.

But in this case load event is not caught because load / on load events dont bubble up.

Promise 
The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.
A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.

In short promise gives a guarantee that the method which is returning promise will return something either success or error.
While chaining .then calls whatever is returned from then method if it is Promise then the next .then method will be chained with the returned promise and the message passed in the callback of current .then will be from the resolve of the promise that was returned from the previous .then callback but if something else is returned say a number or integer then .then chaining will still work but on the main promise in the same sequence as it was registered and it will take that returned integer as its argument in the .then callback.
.catch method call is similar to catch in try catch.
We even have finally method which will be executed no matter if error happened or success happened.

A Promise is in one of these states:

pending: initial state, neither fulfilled nor rejected.
fulfilled: meaning that the operation completed successfully.
rejected: meaning that the operation failed 

The callback passed to new Promise constructor is called executor.

Nested then clause reject cannot be handled by the parent catch. There has to be a chained catch with every .then chain.

In order to remove event listener on an element in javascript we have removeEventListener('eventname', "callback");
In order to remove all the event listeners on an element we need to do a copy and then replace that node with the copy

var new_el = el.cloneNode(true); //true means a deep copy
el.parentNode.replaceChild(new_el,el);
.on was previously called bind()
.off was previously called unbind()

If a simple event name such as "click" is provided, all events of that type (both direct and delegated) are removed from the elements in the jQuery set.

The .off() method removes event handlers that were attached with .on(). See the discussion of delegated and directly bound events on that page for more information. Calling .off() with no arguments removes all handlers attached to the elements. Specific event handlers can be removed on elements by providing combinations of event names, namespaces, selectors, or handler function names. 

Remove all event handlers from all paragraphs:
$( "p" ).off();

Remove all delegated click handlers from all paragraphs:
$( "p" ).off( "click", "**" );

We can even pass two callbacks inside promise object success and failed which can be used to proceed with the .then chain based on the message received in the .then callback. So that if success then we can do something otherwise if error then we can do something else.

promiseReject().then(function() {
    console.log('Success');
    return 1;
}, function() {
    console.log('Error');
    return 2;
}).then(function(message) {
    console.log("Error chain", message);
});

if promise returns an event handler binding then calling that same promise inside .then wont work because all the root calls to promise registered the event handlers initially and so when the event occurred they got called but in case of promise inside .then it registered a new event handler and after it got registered no new events occured hence it was not called.

setTimeout(callback, 2000, params);
params get passed to the callback.

Promise.all is used to watch all the promises inside an array if all resolve then only .then method of .all is called which receives an object with resolve messages of all the resolved promises. but if either one of the promises passed to the .all array rejected then complelete .all is rejected and catch method of .all is called.

all the resolved promises
Promise {<resolved>: 3}__proto__: Promise[[PromiseStatus]]: "resolved"[[PromiseValue]]: 3 Promise {<pending>} 12345 Promise {<resolved>: 40}

resolved promise 
Promise {<resolved>: 3}
__proto__:Promise
[[PromiseStatus]]:"resolved"
[[PromiseValue]]:3

async function is another way of returning the promise without manualy creating a new object. If async function returns anything then proomise is resolved else if error occurs in async function then promise is rejected.

the return value of an async function is implicitly wrapped in Promise.resolve.

Example
async function returnPromise() {
  return 12;
}
returnPromise().then(function() {});

The await operator is used to wait for a Promise. It can only be used inside an async function.
The await expression causes async function execution to pause until  a Promise is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.

If the Promise is rejected, the await expression throws the rejected value.

If the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.

Using setTimeout with async function will not work correctly 

async function returnPromise() {
    setTimeout(function() {
        return "Success";
    }, 500);
}

if returned value from the expression after await returns Promise then await will wait untill promise is resolved or rejected.
if the returned value is not a promise then it will be treated as the resolved promise value.

setTimeout pushes the code in timeout event queue which gets executed in a context other that the holding block and hence aync method returns empty promise.

setTimeout is an async call code doesnot wait for it to get executed. So following method
function test() {
	setTimeout(function() {console.log("Hello")}, 5000);
	console.log("After setTimeout");
}
prints After setTimeout first and exists the function and then after 5 seconds hello is printed.

Await method returns the message passed by resolve or reject methods of Promise.
function waiting() {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            console.log("resolved");
            resolve(30);
        }, 5000);
    });
}
var cld = await waiting(); // cld gets 30
console.log(cld);
