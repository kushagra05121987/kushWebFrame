Node --- 
Dependencies attribute is used for production environment while devDependencies are used for local development environment.
dependencies are install when using npm install on a directory having package.json or npm install $package on other directory not having packge.json
devDependencies are installed using npm install on a directory having package.json unless --production is supplied so if we run 
npm install --production then devDependencies are not installed or if we run npm install $package on a directory not having package.json file then deveDependencies are not installed unless we give --dev option.

Grunt -- 
watch options

these braces are just to create a holder for examples below which helps in rolling the code up they are not required in actual code
{
    options.spawn
    Type: Boolean
    Default: true

    Whether to spawn task runs in a child process. Setting this option to false speeds up the reaction time of the watch (usually 500ms faster for most) and allows subsequent task runs to share the same context. Not spawning task runs can make the watch more prone to failing so please use as needed.

    Example:

    watch: {
    scripts: {
        files: ['**/*.js'],
        tasks: ['jshint'],
        options: {
        spawn: false,
        },
    },
    },
    For backwards compatibility the option nospawn is still available and will do the opposite of spawn.

    options.interrupt
    Type: Boolean
    Default: false

    As files are modified this watch task will spawn tasks in child processes. The default behavior will only spawn a new child process per target when the previous process has finished. Set the interrupt option to true to terminate the previous process and spawn a new one upon later changes.

    Example:

    watch: {
    scripts: {
        files: '**/*.js',
        tasks: ['jshint'],
        options: {
        interrupt: true,
        },
    },
    },

    options.event
    Type: String|Array
    Default: 'all'

    Specify the type of watch events that triggers the specified task. This option can be one or many of: 'all', 'changed', 'added' and 'deleted'.

    Example:

    watch: {
    scripts: {
        files: '**/*.js',
        tasks: ['generateFileManifest'],
        options: {
        event: ['added', 'deleted'],
        },
    },
    },

    options.reload
    Type: Boolean
    Default: false

    By default, if Gruntfile.js is being watched, then changes to it will trigger the watch task to restart, and reload the Gruntfile.js changes. When reload is set to true, changes to any of the watched files will trigger the watch task to restart. This is especially useful if your Gruntfile.js is dependent on other files.

    watch: {
    configFiles: {
        files: [ 'Gruntfile.js', 'config/*.js' ],
        options: {
        reload: true
        }
    }
    }

    options.livereload
    Type: Boolean|Number|Object
    Default: false

    Set to true or set livereload: 1337 to a port number to enable live reloading. Default and recommended port is 35729.

    If enabled a live reload server will be started with the watch task per target. Then after the indicated tasks have run, the live reload server will be triggered with the modified files.

    See also how to enable livereload on your HTML.

    Example:

    watch: {
    css: {
        files: '**/*.sass',
        tasks: ['sass'],
        options: {
        livereload: true,
        },
    },
    },
    Passing an object to livereload allows listening on a specific port and hostname/IP or over https connections (by specifying key and cert paths).

    Example:

    watch: {
    css: {
        files: '**/*.sass',
        tasks: ['sass'],
        options: {
        livereload: {
            host: 'localhost',
            port: 9000,
            key: grunt.file.read('path/to/ssl.key'),
            cert: grunt.file.read('path/to/ssl.crt')
            // you can pass in any other options you'd like to the https server, as listed here: http://nodejs.org/api/tls.html#tls_tls_createserver_options_secureconnectionlistener
        }
        },
    },
    },
}


When working with core javascript functions functions like get element by id and get elements by classname , etc. are bound to find children on the element on which it is called.
So for example when we do something like document.forms[0].email.getElementsByTagName('input') this will find all the input elements inside the element with name email. 

We can also bind elevents like document.forms[0].onmouseover = function(event) {
    console.log(e.target)
}

We can do the same with document.forms[0].addEventListener("click", function(e){console.log('inside clicked')})

If we use submit or any event as name of the element in form then that event will not work because form.<Event Name> is going to give the element and not the event so for example if my submit button's name is submit then form.submit() will not work because form.submit is now an element's name not a function.


Html5 has formenctype attribute to override the enctype given in form 

application/x-www-form-urlencoded ----	Default. All characters are encoded before sent (spaces are converted to "+" symbols, and special characters are converted to ASCII HEX values). Example -- MyVariableOne=ValueOne&MyVariableTwo=ValueTwo

multipart/form-data ----	No characters are encoded. This value is required when you are using forms that have a file upload control

text/plain ----  Spaces are converted to "+" symbols, but no special characters are encoded


During Html5 Validation we get following properties on element getting validated inside javascript 
console.log(elem.validationMessage);
elem.setCustomValidity("custom validation message");
console.log(elem.checkValidity());
console.log(elem.validity);
console.log(elem.validationMessage);
console.log(elem.willValidate);

in addition to this we can have an event oninvalid on the element by which we can trap the invalidation event of an element if we dont want to do it on submit or press of any other button

elem.oninvalid = function(e) {
	console.log("%c On Invalid Event ", "background: black; color: darkgreen", e.target.validity)
}

There are two psuedo elements that we get with html 5 validation they are :valid and :invalid

If we want to insert html using css then we can use before and after psuedo elements to do that.
Remember property is necessary for these psuedo elements to work.

var elem               = document.createElement('div');
    elem.id            = 'notify';
    elem.style.display = 'none';
    form.appendChild(elem);

Filter method in jquery
Reduce the set of matched elements to those that match the selector or pass the function's test.

<ul>
  <li>list item 1</li>
  <li>list item 2</li>
  <li>list item 3</li>
  <li>list item 4</li>
  <li>list item 5</li>
  <li>list item 6</li>
</ul>
We can apply this method to the set of list items:

1
$( "li" ).filter( ":even" ).css( "background-color", "red" );
<ul>
  <li><strong>list</strong> item 1 - one strong tag</li>
  <li><strong>list</strong> item <strong>2</strong> -
    two <span>strong tags</span></li>
  <li>list item 3</li>
  <li>list item 4</li>
  <li>list item 5</li>
  <li>list item 6</li>
</ul>
We can select the list items, then filter them based on their contents:

$( "li" )
  .filter(function( index ) {
    return $( "strong", this ).length === 1;
  })
    .css( "background-color", "red" );

Css3 sibling selectors
ADJACENT SIBLING SELECTORS
p + p { font-size: smaller; } /* Selects all paragraphs that follow another paragraph */
#title + ul { margin-top: 0; } /* Selects an unordered list that directly follows the element with ID title */
GENERAL SIBLING SELECTORS
The general sibling combinator selector is very similar to the adjacent sibling combinator selector we just looked at. The difference is that that the element being selected doesn't need to immediately succeed the first element, but can appear anywhere after it.
If we use the same example structure as above, the last <p> element will be selected by p ~ p as well, because it is preceded by another <p> element, even though not directly.

oninput vs onchange event
oninput event occurs when the text content of an element is changed through the user interface.
onchange occurs when the selection, the checked state or the contents of an element have changed. In some cases, it only occurs when the element loses the focus. The onchange attribute can be used with: <input>, <select>, and <textarea>.


The DOM input event is fired synchronously when the value of an <input>, <select>, or <textarea> element is changed. For input elements with type=checkbox or type=radio, the input event should fire when a user toggles the control (via touch, mouse or keyboard) per the HTML5 specification, but historically, this has not been the case. Check compatibility, or attach to the change event instead for elements of these types.

Additionally, the input event fires on a contenteditable editor when its contents are changed. In this case, the event target is the editing host element. If there are two or more elements which have contenteditable as true, “editing host” is the nearest ancestor element whose parent isn’t editable. Similarly, it’s also fired on root element of designMode editors.


<input type="text" class="test"/>
<textarea></textarea>
<select>
  <option>1</option>
  <option>2</option>
  <option>3</option>
</select>
<pre></pre>

$(".test").on("input", function() {
	$("pre").prepend("\nOn Input.");
}).on("change", function () {
    $("pre").prepend("\nOn change.");
}).on("focus", function () {
    $("pre").prepend("\nOn focus.");
}).on("blur", function () {
    $("pre").prepend("\nOn blur.");
});

$("textarea").change(function() {
	$('pre').prepend("\n On change text area")
}).on("input", function() {
	$("pre").prepend("\nOn Input textarea.");
})

$("select").change(function() {
	$('pre').prepend("\n On change select")
}).on("input", function() {
	$("pre").prepend("\nOn Input Select.");
})

So for html5 custom validations we can check for elements validation as user types using input event.
But still following process is available.

There are two events we need to deal with. First, the invalid event which calls when the value of the input does not match the pattern. We’ll run the following within the invalid event:

input.addEventListener('invalid', function(event){
    event.preventDefault(); ----<<<<<<<---->>>>>>> ------<<<<<< This thing here prevents html5 error message popup from showing. So that we can show our own error messages.
    if ( ! event.target.validity.valid ) {
        elem.textContent   = 'Username should only contain lowercase letters e.g. john';
        elem.className     = 'error';
        elem.style.display = 'block';
 
        input.className    = 'invalid animated shake';
    }
});
Herein, with event.preventDefault();, we prevent the default behavior so that the default browser popup message does not appear. Instead, we are going to show our own through the new div element. We add the text message within the content, add a new class, error and show the message by setting the display to block.

For event bubbling 
A handler on a parent element can always get the details about where it actually happened.
The most deeply nested element that caused the event is called a target element, accessible as event.target.
Note the differences from this (=event.currentTarget):

event.target – is the “target” element that initiated the event, it doesn’t change through the bubbling process.
this – is the “current” element, the one that has a currently running handler on it.

event.stopImmediatePropagation()
If an element has multiple event handlers on a single event, then even if one of them stops the bubbling, the other ones still execute.

In other words, event.stopPropagation() stops the move upwards, but on the current element all other handlers will run.

To stop the bubbling and prevent handlers on the current element from running, there’s a method event.stopImmediatePropagation(). After it no other handlers execute.

To catch an event on the capturing phase, we need to set the 3rd argument of addEventListener to true.

There are two possible values for that optional last argument:

If it’s false (default), then the handler is set on the bubbling phase.
If it’s true, then the handler is set on the capturing phase.
Note that while formally there are 3 phases, the 2nd phase (“target phase”: the event reached the element) is not handled separately: handlers on both capturing and bubbling phases trigger at that phase.

<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Capturing: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Bubbling: ${elem.tagName}`));
  }
</script>

The code sets click handlers on every element in the document to see which ones are working.

If you click on <p>, then the sequence is:

HTML → BODY → FORM → DIV → P (capturing phase, the first listener), and then:
P → DIV → FORM → BODY → HTML (bubbling phase, the second listener).
Please note that P shows up two times: at the end of capturing and at the start of bubbling.

There’s a property event.eventPhase that tells us the number of the phase on which the event was caught. But it’s rarely used, because we usually know it in the handler.


Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.

var a = 100;
It is however important to remember that in the background, JavaScript is religiously declaring then initialising our variables.

As we mentioned before, all variable and function declarations are hoisted to the top of their scope. I should also add that variable declarations are processed before any code is executed.

However, in contrast, undeclared variables do not exist until code assigning them is executed. Therefore, assigning a value to an undeclared variable implicitly creates it as a global variable when the assignment is executed. This means that, all undeclared variables are global variables.


global variables
console.log(hoist); // Output: undefined

var hoist = 'The variable has been hoisted.';

We expected the result of the log to be: ReferenceError: hoist is not defined, but instead, its output is undefined.

Why has this happened?

This discovery brings us closer to wrangling our prey.

JavaScript has hoisted the variable declaration. This is what the code above looks like to the interpreter:

var hoist;

console.log(hoist); // Output: undefined
hoist = 'The variable has been hoisted.';

Function scoped variables
As we've seen above, variables within a global scope are hoisted to the top of the scope. Next, let's look at how function scoped variables are hoisted.

function hoist() {
  console.log(message);
  var message='Hoisting is all the rage!'
}

hoist();
Take an educated guess as to what our output might be.

If you guessed, undefined you're right. If you didn't, worry not, we'll soon get to the bottom of this.

This is how the interpreter views the above code:

function hoist() {
  var message;
  console.log(message);
  message='Hoisting is all the rage!'
}

hoist(); // Ouput: undefined

Strict Mode
Thanks to a utility of the es5 version of JavaScript known as strict-mode, we can be more careful about how we declare our variables. By enabling strict mode, we opt into a restricted variant of JavaScript that will not tolerate the usage of variables before they are declared.

Running our code in strict mode:

Eliminates some silent JavaScript errors by changing them to explicit throw errors which will be spit out by the interpreter.
Fixes mistakes that make it difficult for JavaScript engines to perform optimisations.
Prohibits some syntax likely to be defined in future versions of JavaScript.
We enable strict mode by prefacing our file or function with

'use strict';

// OR
"use strict";
Let's test it out.

'use strict';

console.log(hoist); // Output: ReferenceError: hoist is not defined
hoist = 'Hoisted'; 

const PI;
console.log(PI); // Ouput: SyntaxError: Missing initializer in const declaration
PI=3.142;
Therefore, a constant variable must be both declared and initialised before use.


Function declarations
These are of the following form and are hoisted completely to the top. Now, we can understand why JavaScript enable us to invoke a function seemingly before declaring it.

hoisted(); // Output: "This function has been hoisted."

function hoisted() {
  console.log('This function has been hoisted.');
};

Function expressions
Function expressions, however are not hoisted.

expression(); //Output: "TypeError: expression is not a function

var expression = function() {
  console.log('Will this work?');
};


function a()                                                
{
    var x = 10;

    function x() {
        return 20;
    }

    return x;
}

above will be hoisted like
function a() {
  var x;
  function x() { // this function is assigned to variable indicator "x"
    return 20;
  }
  x = 10; // this overrides the variable indicator "x"
  return x;
}

so variable declaration goes first then function declaration then variable assignment.


javascript ajax for ie 6 or lesser versions
if (window.XMLHttpRequest) {
    //Firefox, Opera, IE7, and other browsers will use the native object
    var request = new XMLHttpRequest();
} else {
    //IE 5 and 6 will use the ActiveX control
    var request = new ActiveXObject("Microsoft.XMLHTTP");
}


req.open( "GET", 'boo.txt', false );
the third parameter is for making the request to synchronous or asynchronous.

req.onreadystatechange = function()
{
    if( req.readyState == 4 && req.status == 200 )
    {
        document.write( req.responseText );
    }
}

0 – The default value when the XMLHttpRequest object is created.
1 – The open() method has been called.
2 – The send() method has been called.
3 – Some data has been retrieved, but the request isn’t finished.
4 – All data has been retrieved and the request is finished.

false in open makes it synchronous default value is true which is asynchronous.

XMLHttpRequest {onreadystatechange: null, readyState: 0, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …}
onabort : null
onerror : null 
onload : null
onloadend : null
onloadstart : null
onprogress : null
onreadystatechange : null
ontimeout : null
readyState : 0
response : ""
responseText : ""
responseType : ""
responseURL : ""
responseXML : null
status : 0
statusText : ""
timeout : 0
upload :
XMLHttpRequestUpload {onloadstart: null, onprogress: null, onabort: null, onerror: null, onload: null, …}
withCredentials : false
__proto__ : XMLHttpRequest


// not all the events will work in synchronous calls but for asynchronous calls all the events will work.

for synchronous calls progress events was received only in onloadend event onloadstart evet didnot fire at all in synchronous call.
Timeout is zero in synchronous call and cannot be changed.

First on progress event for asynchronous calls is received in onLoadStart with lengthComputable: false and loaded:0 and readyState is 2
Second on progress event for asynchronous calls is received in onProgress with lengthComputable: true and loaded:<full length of the object received> and readyState is 3
Third on progress event for asynchronous calls is received in onLoadEnd with lengthComputable: true and loaded:<full length of the object received> and readyState is 4

So xhr.onProgress event gets fired only when complete object is received

for aborting the ajax request 
var xhr = new XMLHttpRequest(),
    method = "GET",
    url = "https://developer.mozilla.org/";
xhr.open(method,url,true);

xhr.send();

xhr.abort();

.ajaxStop() ->>> Register a handler to be called when all Ajax requests have completed. This is an Ajax Event.

Aborting jquery ajax request.
var calculationRequest = null;

function PerformAbortableCalculation()
{
        if(calculationRequest != null)
                calculationRequest.abort();
        calculationRequest = $.get("/tests/calc.php", function(data, textStatus)
        {
                alert(data);
        });
}


req.responseType is supposed to allow only the response type set in this variable as a response from server if response is different the this value is null.
responseText is based on responseType value if responseType is somthing other than text or '' then the responseText is empty.
responseText is string representation of response.
so if responseType is json then responseText is empty.

In jquery ajax responseType id dataType. dataType is you telling jQuery what kind of response to expect.

Accept header tells the server about the type of content it is expecting 
Content-type tells the server about the type of request it is sending.

dataType and accpets must mapped together.

in order to get the response header we need to use getResponseHeader('header name') method.
in order to get all the response headers we need to use getAllResponseHeaders() method.

To set request headers in ajax we can use two approaches by setting headers: {} property on ajax call or by xhr.setRequestHeader in beforeSend


The same-origin policy controls interactions between two different origins, such as when you use XMLHttpRequest or an <img> element. These interactions are typically placed in three categories:

Cross-origin writes are typically allowed. Examples are links, redirects and form submissions. Certain rarely used HTTP requests require preflight.
Cross-origin embedding is typically allowed. Examples are listed below.
Cross-origin reads are typically not allowed, but read access is often leaked by embedding. For example you can read the width and height of an embedded image, the actions of an embedded script, or the availability of an embedded resource.
Here are some examples of resources which may be embedded cross-origin:

JavaScript with <script src="..."></script>. Error messages for syntax errors are only available for same-origin scripts.
CSS with <link rel="stylesheet" href="...">. Due to the relaxed syntax rules of CSS, cross-origin CSS requires a correct Content-Type header. [...]

JSONP is nothing but json with padding. In order to accomplish this we make use of the fact that script tags are not a part of cross-origin restrictions .
So we can call any urls to read stuff using a callback query parameter in request url. The service endpoint responsding to this must give back the output as passing the json argument to that callback in url.
Example
function response(resposne) {
  return response;
}
http://www.abc.com/?callback=callMe
service enpoint should respond with 
callMe({json object values})

datatype:script or .getScript() method work the same they are used to read the resonse as javascript and return it as string.
$.ajax({
  url: url,
  dataType: "script",
  success: success
}); this is equivalent to 
$.getScript( "ajax/test.js", function( data, textStatus, jqxhr ) {
  console.log( data ); // Data returned
  console.log( textStatus ); // Success
  console.log( jqxhr.status ); // 200
  console.log( "Load was performed." );
});

when datatype is jsonp the default callback is supplie in the url if you want to overrite it then we can give an option like 
datatype: jsonp,
jsonp:function(){}

defining jquery function 
$.fn.myfunction = function() {
      alert('hello world');
      return this;
};

when calling function this will give the object on which it is called
so if we cann myfunction() then this will be window because its called on window.myfunction 

global (default: true)
Type: Boolean
Whether to trigger global Ajax event handlers for this request. The default is true. Set to false to prevent the global handlers like ajaxStart or ajaxStop from being triggered. This can be used to control various Ajax Events.

So if we call .json file in ajax jquery we dont get success method executed. The error in this case is unknow but if we use the same request for local server having same origin then it works fine.

Setting xhr.withCredentials = true inside beforeSend doesent work 
instead we need to use xhrFields key 
xhrFields: {
  withCredentials: true
}
withCredentials field need to be set on both server and ui side in order to start setting cookies from server on UI.
Cookies get set if requests are between same domains.

document.cookie are sent to the servers in ajax request when the requests are in same domain but local cookies dont get send to server unless they are set using Set-Cookie header.

Although CORS allows cross-origin requests, the cookies are still subject to the browser's same-origin policy, which means only pages from the same origin can read/write the cookie. withCredentials only means that any cookies set by the remote host are sent to that remote host. You will have to set the cookie from the remote server by using the Set-Cookie header.


upload: XMLHttpRequestUpload
onabort: null
onerror: null
onload: null
onloadend: null
onloadstart: null
onprogress: null
ontimeout: null

when events on upload are bound then events on core xhr object wont work or we can say if both core xhr events and upload events are bound then upload events will take precedence over core events exmaple if xhr.onloadstart and xhr.upload.onloadstart are bound at the same time the xhr.upload.onloadstart will be executed.
On readystate change will be executed on xhr object only.
onload gets executed after the ajax call is completed sucessfully but before onloadEnd is called its available on both xhr and xhr.upload

ProgressEvent {isTrusted: true, lengthComputable: true, loaded: 699, total: 699, type: "load", …}
bubbles:false
cancelBubble:false
cancelable:false
composed:false
currentTarget:XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 4294967295, withCredentials: false, upload: XMLHttpRequestUpload, …}
defaultPrevented:false
eventPhase:0
isTrusted:true
lengthComputable:true
loaded:699
path:[]
returnValue:true
srcElement:XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 4294967295, withCredentials: false, upload: XMLHttpRequestUpload, …}
target:XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 4294967295, withCredentials: false, upload: XMLHttpRequestUpload, …}
timeStamp:2793.985
total:699
type:"load"

we get this object in 4 places onloadstart, onprogress, onload, onloadend.
We need to consider 3 things in this object
lengthComputable: true or false
loaded
total

lengthComputable - a read-only (Boolean) property indicating if the resource concerned by the ProgressEvent has a length that can be calculated
total - a read-only (Unsigned Long) property representing the total amount of work that the underlying process is in the progress of performing
loaded - a read-only (Unsigned Long) property representing the amount of work already performed by the underlying process

'responseXML' property from 'XMLHttpRequest': The value is only accessible if the object's 'responseType' is '' or 'document'

There are two progress events in a XmlHttpRequest object:

The response progress (XmlHttpRequest.onprogress)
This is when the browser is downloading the data from the server.

The request progress (XmlHttpRequest.upload.onprogress)
This is when the browser is sending the data to the server (including POST parameters, cookies, and files)

In your code you are using the response progress event, but what you need is the request progress event. This is how you do it:

$.ajax({
    async: true,
    contentType: file.type,
    data: file,
    dataType: 'xml',
    processData: false,
    success: function(xml){
        // Do stuff with the returned xml
    },
    type: 'post',
    url: '/fileuploader/' + file.name,
    xhr: function(){
        // get the native XmlHttpRequest object
        var xhr = $.ajaxSettings.xhr() ;
        // set the onprogress event handler
        xhr.upload.onprogress = function(evt){ console.log('progress', evt.loaded/evt.total*100) } ;
        // set the onload event handler
        xhr.upload.onload = function(){ console.log('DONE!') } ;
        // return the customized object
        return xhr ;
    }
});

onload event can be used as combination of onreadystate change and readystate = 4

.ajaxStart(): Register a handler to be called when the first Ajax request begins. This is an Ajax Event.

Note: Global callback functions should be set with their respective global Ajax event handler methods—.ajaxStart(), .ajaxStop(), .ajaxComplete(), .ajaxError(), .ajaxSuccess(), .ajaxSend()—rather than within the options object for $.ajaxSetup().

URL provides methods to generate url for blobs. So that we can directly show it in UI and also pass it to the api that accepts it.


WorkerGlobalScope interface is an interface representing scope of any worker.
Workers have no browsing context. This scope contains information usually conveyed by window object.
in this case event handlers, the console or the associated WorkerNavigator object.
WindowNavigator is just representation of window.navigator object.

This interface is usually specialized by each worker type:
DedicatedWorkerGlobalScope for dedicated workers, 
SharedWorkerGlobalScope for shared workers, and 
ServiceWorkerGlobalScope for ServiceWorker. 
The self property returns the specialized scope for each context.


Web workers are of three types 
Dedicated
Shared
Service

When main js starts a worker it spawns a new thread which runs in background without affecting other things.
It can use ajax calls aswell.
But workers don't have any browsing context so inorder to use the global context object window we use self.
	
Web Workers don't have a window object.
To access global state, use self instead, code that will work on both the main thread and the worker thread.
But note that you still won't be able to access or manipulate the parent DOM (e.g. get window.jQuery via self.jQuery).
While the main thread window self points to the Window object, in worker threads self points to a separate WorkerGlobalScope object.

window object is not equal to self object its just a reference to window object and provides the few methods available on window object such as navigator, location, etc. But setting a value in window object and then trying to access it in self is not going to work.

Shared workers can be accessed by multiple scripts and not just one script as in case of dedicated workers.
These scripts can be anywhere inside a different window or frame or script.

Inorder to comunicate in shared workers we need to use port object.
The port connection needs to be started either implicitly by use of the onmessage event handler or explicitly with the start() method before any messages can be posted

When using the start() method to open the port connection, it needs to be called from both the parent thread and the worker thread if two-way communication is needed.

myWorker.port.start();  // called in parent thread
port.start();  // called in worker thread, assuming the port variable references a port

myWorker.port.postMessage([squareNumber.value,squareNumber.value]);

onconnect = function(e) {
  var port = e.ports[0];

  port.onmessage = function(e) {
    var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
    port.postMessage(workerResult);
  }
}

we use an onconnect handler to fire code when a connection to the port happens (i.e. when the onmessage event handler in the parent thread is setup, or when the start() method is explicitly called in the parent thread).

self is equivalent to window in worker file but gives WorkerGlobalScope object and not actual global scope object which in case of Dedicated worker is DedicatedWorkerGlobalScope and in case of shared SharedWorkerGlobalScope.

Service workers work only with https requests and async requests so localstorage and synchronous XHR are not allow.

Service worker scopes are restricted to both the location of service worker file and the current url.
If service worker file is inside a directory such as src then it will be restricted to track the fetching of
files inside that directory.

If the current page url or request url is different than the directory of service worker and we use scope like {scope: './'} then error is thown that the request we are trying to make is out of scope of service worker and then inorder to resolve this we need to move the service worker script to another location to match the request url or we need to add Service-Worker-Allowed: true or we can omit the scope argument.

Install event allows to registers specific resources for worker such as caches.
while install is happening we get one more event
event.waitUntill to wait untill the installation process is completed and install stage in resolved.
if install event is taking too long the we can even skip it by self.skipWaiting()

After the install is finished and is waiting for the clients using other service workers to be closed.

Activate state begins when there are no workers left on which clients are working. This stage can be used to clean up anything that was being used by other clients and workers and now after they have stopped they are no more requied.

Activate events can also be extended and be waited for to be finished using same methods as above in install phase
event.waitUntill
and self.clients.claim() --- start handling and controlling all open clients without reloading them. 

So while serving script files from servers that have htaccess support we can set the response headers in htaccess file like 
Header add Custom-Header "parameter=value"
request will be 
GET / HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
DNT: 1
Connection: keep-alive
Cache-Control: max-age=0

.to which the server responded with the following headers:

HTTP/1.1 200 OK
Server: nginx
Date: Mon, 01 Aug 2016 17:58:14 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
X-Powered-By: PHP/5.6.24, PleskLin
strict-transport-security: max-age=63072000; includeSubDomains; preload
Cache-Control: no-cache, no-store, must-revalidate
Pragma: no-cache
Expires: 0
Custom-Header: parameter=value
Content-Language: en

there i can also check if file requested is a js file or not

Fetch API
There are new objects like Request, response and fetch().
Fetch is used to fetch any resource like a normal ajax call . It takes as an argument the request object or url string and returns back a promise object which can be clubbed with then and catch methods.
Then method receives Response object.

Promise<Response> fetch(input[, init]);
Parameters
input
This defines the resource that you wish to fetch. This can either be:
A USVString containing the direct URL of the resource you want to fetch. Some browsers accept blob: and data: as schemes.
A Request object.
init Optional
An options object containing any custom settings that you want to apply to the request. The possible options are:
method: The request method, e.g., GET, POST.
headers: Any headers you want to add to your request, contained within a Headers object or an object literal with ByteString values.
body: Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
mode: The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
credentials: The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided. Starting with Chrome 50, this property also takes a FederatedCredential instance or a PasswordCredential instance.
cache: The cache mode you want to use for the request: default, no-store, reload, no-cache, force-cache, or only-if-cached.
redirect: The redirect mode to use: follow (automatically follow redirects), error (abort with an error if a redirect occurs), or manual (handle redirects manually). In Chrome the default was follow before Chrome 47 and manual starting with Chrome 47.
referrer: A USVString specifying no-referrer, client, or a URL. The default is client.
referrerPolicy: Specifies the value of the referer HTTP header. May be one of no-referrer, no-referrer-when-downgrade, origin, origin-when-cross-origin, unsafe-url.
integrity: Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).
keepalive: The keepalive option can be used to allow the request to outlive the page. Fetch with the keepalive flag is a replacement for the Navigator.sendBeacon() API. 
signal: An AbortSignal object instance; allows you to communicate with a fetch request and abort it if desired via an AbortController.

Request object is for preparing and creating a request object which can be passed to fetch.
It takes input and init as arguments.
Input can be url or another request object.
Init can be an options object with method, headers, body which can be Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object, mode which can be cors, no-cors, same-origin, or navigate, credentials, etc

var myRequest = new Request(input, init);
Parameters
input
Defines the resource that you wish to fetch. This can either be:
A USVString containing the direct URL of the resource you want to fetch.
A Request object, effectively creating a copy. Note the following behavioural updates to retain security while making the constructor less likely to throw exceptions:
If this object exists on another origin to the constructor call, the Request.referrer is stripped out.
If this object has a Request.mode of navigate, the mode value is converted to same-origin.
init Optional
An options object containing any custom settings that you want to apply to the request. The possible options are:
method: The request method, e.g., GET, POST.
headers: Any headers you want to add to your request, contained within a Headers object or an object literal with ByteString values.
body: Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object. Note that a request using the GET or HEAD method cannot have a body.
mode: The mode you want to use for the request, e.g., cors, no-cors, same-origin, or navigate. The default is cors. In Chrome the default is no-cors before Chrome 47 and same-origin starting with Chrome 47.
credentials: The request credentials you want to use for the request: omit, same-origin, or include. The default is omit. In Chrome the default is same-origin before Chrome 47 and include starting with Chrome 47.
cache: The cache mode you want to use for the request.
redirect: The redirect mode to use: follow, error, or manual. In Chrome the default is manual before Chrome 47 and follow starting with Chrome 47.
referrer: A USVString specifying no-referrer, client, or a URL. The default is client.
integrity: Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).


Response is the object for preparing and creating a response along with body and headers. which can then be passed to other calling methods.

It takes two arguments body and init as options.
BOdy can be one of the following
Blob
BufferSource
FormData
ReadableStream
URLSearchParams
USVString

init takes following options
status,
statusText,
headers

headers in both request and response are an object of Headers which has some methods like get getall append delete has etc

File Blob and Filereader

File is an extension on Blob object. Its specific use is to create a reference object for a file which will give some meta properties of file such as size, last modified, name , type , etc.

File does not define any methods of its own. It inherits them from blob.

File constructor takes three arguments 
An Array of ArrayBuffer, ArrayBufferView, Blob, or DOMString objects — or a mix of any such objects. This is the file content encoded as UTF-8.
name of file,
options which include 
type and lastModified
var file = new File(["foo"], "foo.txt", {
  type: "text/plain",
});


Blob is the representation of file like objects in raw immutable form.
We can construct blob object from other non blob objects using Blob() constructor
Blob constructor takes two arguments
An Array of ArrayBuffer, ArrayBufferView, Blob, or DOMString objects — or a mix of any such objects. This is the file content encoded as UTF-8.
options which contains type -> the mine type of the file 
endings: which defines how the line breaks in the given data are supposed to be treated in new raw file. The values are native which converts all breaks into os specific breaks. Transparent which keeps the breaks as it is.

var aFileParts = ['<a id="a"><b id="b">hey!</b></a>']; // an array consisting of a single DOMString
var oMyBlob = new Blob(aFileParts, {type : 'text/html'}); // the blob

New blob can be constructed from another blob object using slice method
Slice is browser specific method which means for different browsers we have different variants of slice.

var blob = instanceOfBlob.slice([start [, end [, contentType]]]);

To obtain a Blob object for a file on the user's file system we use File object.


The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read.

Properties
FileReader.error Read only
A DOMException representing the error that occurred while reading the file.
FileReader.readyState Read only
A number indicating the state of the FileReader. This is one of the following:
EMPTY	0	No data has been loaded yet.
LOADING	1	Data is currently being loaded.
DONE	2	The entire read request has been completed.
FileReader.result Read only
The file's contents. This property is only valid after the read operation is complete, and the format of the data depends on which of the methods was used to initiate the read operation.

Event handlers
FileReader.onabort
A handler for the abort event. This event is triggered each time the reading operation is aborted.
FileReader.onerror
A handler for the error event. This event is triggered each time the reading operation encounter an error.
FileReader.onload
A handler for the load event. This event is triggered each time the reading operation is successfully completed.
FileReader.onloadstart
A handler for the loadstart event. This event is triggered each time the reading is starting.
FileReader.onloadend
A handler for the loadend event. This event is triggered each time the reading operation is completed (either in success or failure).
FileReader.onprogress
A handler for the progress event. This event is triggered while reading a Blob content.


Methods
FileReader.abort()
Aborts the read operation. Upon return, the readyState will be DONE.
FileReader.readAsArrayBuffer()
Starts reading the contents of the specified Blob, once finished, the result attribute contains an ArrayBuffer representing the file's data.
FileReader.readAsBinaryString() 
Starts reading the contents of the specified Blob, once finished, the result attribute contains the raw binary data from the file as a string.
FileReader.readAsDataURL()
Starts reading the contents of the specified Blob, once finished, the result attribute contains a data: URL representing the file's data.
FileReader.readAsText()
Starts reading the contents of the specified Blob, once finished, the result attribute contains the contents of the file as a text string.

FileReader object and File can be used with File , blob or even with FileList object from input elements.

FileList ->>> FileList is the object which represents the list of files in given file input element.
var inputFile = document.getElementsByName("file").item(0);
so inputFile.files will give FileList

createDocumentFragment doesnot modify the actual untill its added to html . It creates a virtual dom or fragment and we keep on doing modification to that but not to actual dom.
createElement transparently in the backend keep manipulating the DOM though we not see it in the page but it actually modifies the dom.

File and Blobs cannot read file on local machine unless they are uploaded.

Script type
module: HTML5 For HTML5-compliant browsers the code is treated as a JavaScript module. The processing of the script contents is not affected by the charset and defer attributes.

Module types js are automatically 'use-strict'
Module types can use import and exports.
Module types behave like defer by default.
Defer by default
<!-- This script will execute after… -->
<script type="module" src="1.js"></script>

<!-- …this script… -->
<script src="2.js"></script>

<!-- …but before this script. -->
<script defer src="3.js"></script>

nomodule 
This Boolean attribute is set to indicate that the script should not be executed in browsers that support ES6 modules — in effect, this can be used to serve fallback scripts to older browsers that do not support modular JavaScript code.

Async works on external & inline modules
<!-- This executes as soon as its imports have fetched -->
<script async type="module">
  import {addTextToBody} from './utils.js';

  addTextToBody('Inline module executed.');
</script>

<!-- This executes as soon as it & its imports have fetched -->
<script async type="module" src="1.js"></script>


<!-- 1.js only executes once -->
Modules only execute once
<script type="module" src="1.js"></script>
<script type="module" src="1.js"></script>
<script type="module">
  import "./1.js";
</script>

<!-- Whereas normal scripts execute multiple times -->
<script src="2.js"></script>
<script src="2.js"></script>

Always CORS
<!-- This will not execute, as it fails a CORS check -->
<script type="module" src="https://….now.sh/no-cors"></script>

<!-- This will not execute, as one of its imports fails a CORS check -->
<script type="module">
  import 'https://….now.sh/no-cors';

  addTextToBody("This will not execute.");
</script>

<!-- This will execute as it passes CORS checks -->
<script type="module" src="https://….now.sh/cors"></script>

No credentials
<!-- Fetched with credentials (cookies etc) -->
<script src="1.js"></script>

<!-- Fetched without credentials -->
<script type="module" src="1.js"></script>

<!-- Fetched with credentials -->
<script type="module" crossorigin src="1.js?"></script>

<!-- Fetched without credentials -->
<script type="module" crossorigin src="https://other-origin/1.js"></script>

<!-- Fetched with credentials-->
<script type="module" crossorigin="use-credentials" src="https://other-origin/1.js?"></script>

In HTML5, some HTML elements which provide support for CORS, such as <img>, <video> or <script>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data. These attributes are enumerated, and have the following possible values:

Keyword	Description
anonymous	CORS requests for this element will not have the credentials flag set.
use-credentials	CORS requests for this element will have the credentials flag set; this means the request will provide credentials.
By default (that is, when the attribute is not specified), CORS is not used at all. The "anonymous" keyword means that there will be no exchange of user credentials via cookies, client-side SSL certificates or HTTP authentication

When you use the crossorigin attribute it sets the "use-URL-credentials" flag and maps anonymous to "same-origin" and use-credentails to "include" for the crendentials mode. If you omit the crossorigin attribute, "use-URL-credentials" is unset and, the default for credentials mode is assumed, which is omit.

You can add credentials to a same-origin module by including the crossorigin attribute (which seems a bit weird to me, and I've questioned this in the spec). If you want to send credentials to other origins too, use crossorigin="use-credentials".



using module we can use import and export but for other features we dont need to use module. Normal text/javascript will work.

nomodule works only with text/javascript. If given with tyep module its omitted and script still executes.

Error: Failed to load http://sysblog.local:8080/index.php: Response for preflight is invalid (redirect)
indicates that the page requested is redirecting the user somewhere.

jqXHR is superset of xhr which is actual representation of XMLHttpRequest object.

Access-Control-Allow-Origin
Access-Control-Allow-Credentials
these are headers which are required to be present in both OPTIONS request and GET request.

it is contentType in ajax call that defines enctype of form
using application/x-www-form-urlencoded, multipart/form-data, or text/plain values with contentType will mimic the behaviour of actual form submission with enctype as these values.

crossDomain jquery option -> If you wish to force a crossDomain request (such as JSONP) on the same domain, set the value of crossDomain to true 

converters (default: {"* text": window.String, "text html": true, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML})
Type: PlainObject
An object containing dataType-to-dataType converters. Each converter's value is a function that returns the transformed value of the response. 

Default value of content-type header (in ajax or form) or enctype (in form) is application/x-www-form-urlencoded.

if data is sent as application/x-www-form-urlencoded it is received in both $_POST and php://input stream ( as name=kushagra&age=38).

processData By default, data passed in to the data option as an object (technically, anything other than a string) will be processed and transformed into a query string, fitting to the default content-type "application/x-www-form-urlencoded".  If you want to send a DOMDocument, or other non-processed data, set this option to false.

Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding:gzip, deflate
Accept-Language:en-US,en;q=0.9,fr;q=0.8
Cache-Control:max-age=0
Connection:keep-alive
Content-Length:365
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrosnbEUsHNClsQYZ
Cookie:PHPSESSID=m9tpj4fnn5n7uh48s939n7ri32
DNT:1
Host:sysblog.local:8080
Origin:http://localhost:9000
Referer:http://localhost:9000/
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36

------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="email"

karizmatic.kay@gmail.com
------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="firstname"

Kushagra
------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="lastname"

Mishra
------WebKitFormBoundary76JWxVOm9dQTKlbs
Content-Disposition: form-data; name="ufile"; filename="adhaar.png"
Content-Type: image/png


------WebKitFormBoundary76JWxVOm9dQTKlbs--

multipart/formdata 
With this method of transmitting name/value pairs, each pair is represented as a "part" in a MIME message (as described by other answers). Parts are separated by a particular string boundary (chosen specifically so that this boundary string does not occur in any of the "value" payloads). Each part has its own set of MIME headers like Content-Type, and particularly Content-Disposition, which can give each part its "name." The value piece of each name/value pair is the payload of each part of the MIME message. The MIME spec gives us more options when representing the value payload -- we can choose a more efficient encoding of binary data to save bandwidth (e.g. base 64 or even raw binary).

So as we can see the multipart/formdata request uses boundries for every key/value pair which creates its own mime-type . So very mime has its own set of headers such as content type and content Disposition

This type of behaviour cannot be mimiced with normal ajax flow hence we need Formdata otherwise it prepares a query string similar to application/x-www-form-urlencoded with & and %20.

Content-Type can be anything event application/kushagra and whatever we pass as a data for post method 
it will be converted to application/x-www-form-urlencoded format with & and %20 or whatever encoding is required.

If enctype is unsupported (even if it is application/json) then it will automatically convert to application/x-www-form-urlencoded such as in case of application/kushagra.

text/plain enctype sends request payload and not form data like in normal application/x-www-form-urlencoded request. Hence it can only be retrieved from php://input.In this case only filename will go with the post request and not actual file object.
email=karizmatic.kay@gmail.com
firstname=Kushagra
lastname=Mishra
ufile=adhaar.png

but if used with ajax calls then the request payload goes as in application/x-www-form-urlencoded.
name=kushagra&age=38

Whatever w3school says about text/plain enctype is wrong no encryption is performed even + is not used

In XMLHttpRequest content type with value application/x-www-form-urlencoded, multipart/formdata, text/plain if the actual content is not in required format the value gets converted to application/x-www-form-urlencoded format that is with & and %20 etc.
So if json value or anyother value other than normal text is supplied with text/plain or json value, anyother value which is not multipart request with boundary is supplied with multipart/formdata or any other content-type then the payload is converted to application/x-www-form-urlencoded.

Blob can set its content-type and hence we can see the use of other property Content-Type in multipart request which belongs to only a specific mime subpart.

"------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="username"

Groucho
------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="accountnum"

123456
------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="ufile"

undefined
------WebKitFormBoundaryXlk8RvQzJKAhmGr4
Content-Disposition: form-data; name="webmasterfile"; filename="blob"
Content-Type: text/xml

<a id="a"><b id="b">hey!</b></a>
------WebKitFormBoundaryXlk8RvQzJKAhmGr4--
"

when sending formdata with file through ajax we need to skip setting content-type header because for multipart requests we need to set boundary value also with multipart/formdata which when setting manually can't be set so we need to just let it set automatically which will add boundary value. Content-Type:multipart/form-data; boundary=----WebKitFormBoundarybkqwsY2nEFys9wg5

If no content-type is set and json or anyother unsupported format like text is passed then in core XmlHttpRequest it is passed as raw data with text/plain as content-type.

Which in case of jquery ajax would have been set to application/x-www-form-urlencoded and data converted accordingly.

.hover() is jquery event it binds tagNameo events mouseenter and mouseleave.

For upload both xhr.progressEvent and xhr.upload.progressEvent work in which xhr.progressEvent does not give the total amount to be uploaded, it only gives the amount upload till now but xhr.upload.progressEvent will give both the uploaded aswell as total to be uploaded.
Upload process is not completed untill xhr.progressEvent is finished and xhr.onload event is fired or xhr.readyState is 4. 

for downloading using jquery ajax we need to setup responseType to blob , dataType: blob doesnot work.

The response progress (XmlHttpRequest.onprogress)
This is when the browser is downloading the data from the server.

The request progress (XmlHttpRequest.upload.onprogress)
This is when the browser is sending the data to the server (including POST parameters, cookies, and files)

progressevent on ajax should be bound using xhrFiles anyother way will not work
xhrFields: {
    withCredentials: true,
    responseType: 'blob',
    onprogress: function(e) {console.log("%c On Progress ", "background: darkgreen; color: #ffffff", e);}
},

We can het XmlHttpRequest object in jquery ajax using $.ajaxSettings.xhr();
Where as $.ajaxSettings gives the json object of settings done by $.ajaxSetup

accepts:{*: "*/*", text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript", …}
async:true
contentType:"application/x-www-form-urlencoded; charset=UTF-8"
contents:{xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/, script: /\b(?:java|ecma)script\b/}
converters:{* text: ƒ, text html: true, text json: ƒ, text xml: ƒ, text script: ƒ}
flatOptions:{url: true, context: true}
global:true
isLocal:false
jsonp:"callback"
jsonpCallback:ƒ ()
processData:true
responseFields:{xml: "responseXML", text: "responseText", json: "responseJSON"}
type:"GET"
url:"http://localhost:9000/"
xhr:ƒ ()


xhr: function() {} is the callback used to prepare XmlHttpRequest object and hence here we can bind upload progress event 
xhr: function() {
    var myXhr = $.ajaxSettings.xhr();
    myXhr.upload.onprogress = function(e) {console.log("%c On Progress Upload ", "background: orange; color: #ffffff", e);}
    return myXhr;
},

delete operator removes property from object.


Web applications can allow or disallow other webapplication to incude their pages in an iframe by using following header
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM https://example.com/

inorder to add headers in htaccess request we need to enable mod_headers directive in apache.

Chrome and Safari don't support X-Frame-Options
so for that we need to use Content-Security-Policy
Syntax
Content-Security-Policy: <policy-directive>; <policy-directive>

This response header tell the browser that load different sections according to the given value in the header such as
default-src
Serves as a fallback for the other fetch directives.
font-src
Specifies valid sources for fonts loaded using @font-face.
frame-src
Specifies valid sources for nested browsing contexts loading using elements such as <frame> and <iframe>.
img-src
Specifies valid sources of images and favicons.
manifest-src
Specifies valid sources of application manifest files.
media-src
Specifies valid sources for loading media using the <audio> , <video> and <track> elements.
object-src
Specifies valid sources for the <object>, <embed>, and <applet> elements.
script-src
Specifies valid sources for JavaScript.
style-src
Specifies valid sources for stylesheets.
worker-src
Specifies valid sources for Worker, SharedWorker, or ServiceWorker scripts.

It can be used as response header as well as a meta tag 
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
with unsafe inline we can allow the use of inline <script> tags , javascript: and also inline event handlers which otherwise wont be allowed.

Content-Security-Policy actually gives a white list of src to browser to load resources from these src's only.

From the DOM iframe element, scripts can get access to the window object of the included HTML page via the contentWindow property. The contentDocument property refers to the document element inside the iframe (this is equivalent to contentWindow.document), but is not supported by Internet Explorer versions before IE8.

We cannot access the content of another window such as iframe window(iframe.contentWindow) or new window from window.open or anyother window from different domain using javascript. Hence in order to communicate between different windows from different origins we make use of Message event and postMessage method on window object.


window.history.back();
window.history.forward();
window.history.go(-1);
window.history.go(1);
var numberOfEntries = window.history.length;

onpopstate is an event handler for the popstate event on the window.

A popstate event is dispatched to the window each time the active history entry changes between two history entries for the same document. If the activated history entry was created by a call to history.pushState(), or was affected by a call to history.replaceState(), the popstate event's state property contains a copy of the history entry's state object.

Note: calling history.pushState() or history.replaceState() won't trigger a popstate event. The popstate event is only triggered by performing a browser action, such as clicking on the back button (or calling history.back() in JavaScript), when navigating between two history entries for the same document.

window.onpopstate = function(event) {
  alert("location: " + document.location + ", state: " + JSON.stringify(event.state));
};

history.pushState({page: 1}, "title 1", "?page=1");
history.pushState({page: 2}, "title 2", "?page=2");
history.replaceState({page: 3}, "title 3", "?page=3");
history.back(); // alerts "location: http://example.com/example.html?page=1, state: {"page":1}"
history.back(); // alerts "location: http://example.com/example.html, state: null
history.go(2);  // alerts "location: http://example.com/example.html?page=3, state: {"page":3}

Popstate event 
PopStateEvent {isTrusted: true, state: {…}, type: "popstate", target: Window, currentTarget: Window, …}
bubbles:false
cancelBubble:false
cancelable:true
composed:false
currentTarget:Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
defaultPrevented:false
eventPhase:0
isTrusted:true
path:[Window]
returnValue:true
srcElement:Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
state:{foo: "bar"}
target:Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
timeStamp:16264.45
type:"popstate" 


Example of pushState() method
Suppose http://mozilla.org/foo.html executes the following JavaScript:

var stateObj = { foo: "bar" };
history.pushState(stateObj, "page 2", "bar.html");

The pushState() method
pushState() takes three parameters: a state object, a title (which is currently ignored), and (optionally) a URL. Let's examine each of these three parameters in more detail:

state object — The state object is a JavaScript object which is associated with the new history entry created by pushState(). Whenever the user navigates to the new state, a popstate event is fired, and the state property of the event contains a copy of the history entry's state object.

The state object can be anything that can be serialized. Because Firefox saves state objects to the user's disk so they can be restored after the user restarts the browser, we impose a size limit of 640k characters on the serialized representation of a state object. If you pass a state object whose serialized representation is larger than this to pushState(), the method will throw an exception. If you need more space than this, you're encouraged to use sessionStorage and/or localStorage.

title — Firefox currently ignores this parameter, although it may use it in the future. Passing the empty string here should be safe against future changes to the method. Alternatively, you could pass a short title for the state to which you're moving.

URL — The new history entry's URL is given by this parameter. Note that the browser won't attempt to load this URL after a call to pushState(), but it might attempt to load the URL later, for instance after the user restarts the browser. The new URL does not need to be absolute; if it's relative, it's resolved relative to the current URL. The new URL must be of the same origin as the current URL; otherwise, pushState() will throw an exception. This parameter is optional; if it isn't specified, it's set to the document's current URL.

hashchange event is fired when location's href changes.

pushstate changes the current url and creates a new state and pushes it to the history so that the url of the page containing the pushstate script is still in history. and hence when we click back button we can get to that url but in case of replaceState the url of the page that included replaceState script will be removed from the history and replaced the new state defined by replaceState.

Jquery's `on` method helps to bind events based on when they bubble or when event occurs directly to the objects that are present at time of event attaching.
so 
When doing something like 
$(window).on('load', function(e) {
    console.log("Body Load Done", e)
})
load event is directly bound to window object which is present at all times.

but when doing something like 
$(window).on('load','body', function(e) {
    console.log("Body Load Done", e)
})
load event callback doesnot gets called because above is delegated way of binding events when they bubble up to the element to which the event is actully bound, in this case window.

Delegation helps us to bind events with elements which are of present at time time of binding but will be available sometime later.

So above call is trying to bind an event on body inside a window element , because body is not available in start or at the time when this event will be bound hence we are using window to bind the event so that when body is avaiable, any event that occurs on body will propogate up till window and there we catch the event on window binding.

But in this case load event is not caught because load / on load events dont bubble up.

Promise 
The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.
A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.

In short promise gives a guarantee that the method which is returning promise will return something either success or error.
While chaining .then calls whatever is returned from then method if it is Promise then the next .then method will be chained with the returned promise and the message passed in the callback of current .then will be from the resolve of the promise that was returned from the previous .then callback but if something else is returned say a number or integer then .then chaining will still work but on the main promise in the same sequence as it was registered and it will take that returned integer as its argument in the .then callback.
.catch method call is similar to catch in try catch.
We even have finally method which will be executed no matter if error happened or success happened.

A Promise is in one of these states:

pending: initial state, neither fulfilled nor rejected.
fulfilled: meaning that the operation completed successfully.
rejected: meaning that the operation failed 

The callback passed to new Promise constructor is called executor.

Nested then clause reject cannot be handled by the parent catch. There has to be a chained catch with every .then chain.

In order to remove event listener on an element in javascript we have removeEventListener('eventname', "callback");
In order to remove all the event listeners on an element we need to do a copy and then replace that node with the copy

var new_el = el.cloneNode(true); //true means a deep copy
el.parentNode.replaceChild(new_el,el);
.on was previously called bind()
.off was previously called unbind()

If a simple event name such as "click" is provided, all events of that type (both direct and delegated) are removed from the elements in the jQuery set.

The .off() method removes event handlers that were attached with .on(). See the discussion of delegated and directly bound events on that page for more information. Calling .off() with no arguments removes all handlers attached to the elements. Specific event handlers can be removed on elements by providing combinations of event names, namespaces, selectors, or handler function names. 

Remove all event handlers from all paragraphs:
$( "p" ).off();

Remove all delegated click handlers from all paragraphs:
$( "p" ).off( "click", "**" );

We can even pass two callbacks inside promise object success and failed which can be used to proceed with the .then chain based on the message received in the .then callback. So that if success then we can do something otherwise if error then we can do something else.

promiseReject().then(function() {
    console.log('Success');
    return 1;
}, function() {
    console.log('Error');
    return 2;
}).then(function(message) {
    console.log("Error chain", message);
});

if promise returns an event handler binding then calling that same promise inside .then wont work because all the root calls to promise registered the event handlers initially and so when the event occurred they got called but in case of promise inside .then it registered a new event handler and after it got registered no new events occured hence it was not called.

setTimeout(callback, 2000, params);
params get passed to the callback.

Promise.all is used to watch all the promises inside an array if all resolve then only .then method of .all is called which receives an object with resolve messages of all the resolved promises. but if either one of the promises passed to the .all array rejected then complelete .all is rejected and catch method of .all is called.

all the resolved promises
Promise {<resolved>: 3}__proto__: Promise[[PromiseStatus]]: "resolved"[[PromiseValue]]: 3 Promise {<pending>} 12345 Promise {<resolved>: 40}

resolved promise 
Promise {<resolved>: 3}
__proto__:Promise
[[PromiseStatus]]:"resolved"
[[PromiseValue]]:3

async function is another way of returning the promise without manualy creating a new object. If async function returns anything then proomise is resolved else if error occurs in async function then promise is rejected.

the return value of an async function is implicitly wrapped in Promise.resolve.

Example
async function returnPromise() {
  return 12;
}
returnPromise().then(function() {});

The await operator is used to wait for a Promise. It can only be used inside an async function.
The await expression causes async function execution to pause until  a Promise is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.

If the Promise is rejected, the await expression throws the rejected value.

If the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.

Using setTimeout with async function will not work correctly 

async function returnPromise() {
    setTimeout(function() {
        return "Success";
    }, 500);
}

if returned value from the expression after await returns Promise then await will wait untill promise is resolved or rejected.
if the returned value is not a promise then it will be treated as the resolved promise value.

setTimeout pushes the code in timeout event queue which gets executed in a context other that the holding block and hence aync method returns empty promise.

setTimeout is an async call code doesnot wait for it to get executed. So following method
function test() {
	setTimeout(function() {console.log("Hello")}, 5000);
	console.log("After setTimeout");
}
prints After setTimeout first and exists the function and then after 5 seconds hello is printed.
setInterval is also asynchronous operation as setTimeout.

Await method returns the message passed by resolve or reject methods of Promise.
function waiting() {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            console.log("resolved");
            resolve(30);
        }, 5000);
    });
}
var cld = await waiting(); // cld gets 30
console.log(cld);

In order to get various information about function like the number of arguments and the caller we can use 'arguments' keyword.
callee:ƒ Hello()
length:0
Symbol(Symbol.iterator):ƒ values()
__proto__:Object

callee gives the calling method.
length gives the number of arguments received by the function.

Jquery.Deffered() returns a factory Deffered object which is similar to javascript Promise and hence we can bind .then(), .done(), .always(), .fail() and the method receiving deferred object can call .resolve or .resolveWith and .reject or .rejectWith().

.always() is executed when either of resolve or reject is executed. Its similar to finally.

Deferred object has same states as javascript Promise object that is initial Pending, then Resolved or Rejected (known as fulfilled) and then finished.

$.Deferred() takes a callback which is optional, it run just before the actual deferred object is returned. This object is the actual new deferred object and is passed as first argument.

$.Deferred(function(deferred) {
	console.log("Before ",deferred)
});

Both in javascript Promise and $.Deffered once state is resolved or rejected it cannot be changed to other.

function returnVal() {
	return new Promise(function(resolve, reject) {
		setTimeout(reject, 5000, "failed");
		setTimeout(resolve, 5000, "success");
    });
}
Promise {<pending>}
api.jquery.com/:1 Uncaught (in promise) failed

once the state is resolved or rejected any .then or .done() methods attached to the chain will get immediately executed.

If state is resolved or rejected then any .then methods attached to it are immediately executed.

Once the reject is handled in one .catch it will not get passed to another subsequent catch calls.

The callbacks attached to done() will be fired when the deferred is resolved. The callbacks attached to fail() will be fired when the deferred is rejected.

Prior to jQuery 1.8, then() was just syntactic sugar:

promise.then( doneCallback, failCallback )
// was equivalent to
promise.done( doneCallback ).fail( failCallback )

$.Deferred gives a complete object with handler methods as well as state changing methods thats why we use the same object to return as a promise to the calling function and also to bind the state changer methods such as resolve, reject, resolveWith, rejectWith in the called method. And thats why its not secure to share $.Deffered to other methods because they can modify the promise state there, hence $.Deffered.promise() is used which gives only binding methods such as .then, .done, .always, .progress, etc.

Description: Return a Deferred's Promise object.
deferred.promise( [target ] )
target
Type: Object
Object onto which the promise methods have to be attached.

.progress is used to bind live notification from the promise object before it is resolved or rejected. .notify is used to in conjunction with .progress to keep sending information from promise object to calling method.

In $.Deferred we can pass any number of arguments in the .then, .done, .fail method callback but in case of javascript Promise only one argument can be passed.

$.when is similar to Promise.all. .all method takes array but $.when takes any number of Thenable arguments without array.

If $.when is passed single thenable argument then it will bind all the subsequent then, done, fail, etc to the deferred or promise object returned from that argument.

If $.when is passed a single argument that is not a promise or deferred then it will be immediately resolved and any then , etc callbacks attached will be called.

If $.when is passed with a number of Thenable arguments then a master Deferred object will be created which will watch all the Deffered objects passed into the $.when method and when all of them have resolved or if a single one fails then its resolved or rejected.

If $.when is passed nothing then immediatelya resolved promise is returned.

.promise() Return a Promise object to observe when all actions of a certain type bound to the collection, queued or not, have finished.
The .promise() method returns a dynamically generated Promise that is resolved once all actions of a certain type bound to the collection, queued or not, have ended.

By default, type is "fx", which means the returned Promise is resolved when all animations of the selected elements have completed.

.promise() works same as $.when

Jquery $.get and $.post both give jqXHR object which implements $.Deffered Promise interface ( not exactly $.Deffered ) and hence methods like .then(), .done() etc are available to bind with this object.


When we serialize a form it prepares a query string like get "email=&firstname=&lastname="

$.get, $.post and $.ajax all return jqXHR which also implements promise interface from $.deferred and hence only the methods such as .then and .done are available in addition to a success callback.

jquery .then method takes three callbacks ƒ ( onFulfilled, onRejected, onProgress )

Same origin policy
Allows or defines how a resource on one origin can interact with the resource on other origin.
SOP restricts two origins to talk to each other if they are on different domain, port or schemes(http or https).
There are still some exceptions such as 
Embedding of img, script and link are allowed. 
Post or write requests are allowed.
Read requests are not allowed but can be tricked using embbeding.

Application can change their domain using document.domain with some limitations.
document.domain can change the current domain to the superdomain such as in case of ltl.binarybulb.com document.domain can be changed to binarybulb.com but not to xyz.com.
The change is supposed to be done on both the sides on the pages that can include javascript which can run document.domain.

When doing document.domain port are also replaced with null.

While working with localstorage and cookies they will work only on same origins because they are origin dependent and for every origin they are different.

Things like iframe are allowed to be embedded but with X-Frame-Options or Content-Security-Policy. They are still not allowed to be accessed from a frame from different domain using contentDocument or contentWindow.document. But scripts execution is allowed.
Other things like
Media files with <video> and <audio>.
Plug-ins with <object>, <embed> and <applet>.
Fonts with @font-face. Some browsers allow cross-origin fonts, others require same-origin fonts.
are also allowed.

Ajax calls are subjected to same origin policy.
So even if we include or embed things like js and all from different origins without any issues if those files make cross domain ajax requests then they wont be allowed because now the requests originates from our server and pings other remote server.

For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts. 
 XMLHttpRequest and the Fetch API follow the same-origin policy.

 During cross domain requests even it is a simple request which does not trigger options request Cors header Access-Control-Allow-Origin is required because the request is from different origin and hence it needs to be allowed.

Requests are treated as CORS request and a preflight request is sent when either the method or headers are not one out of the following 
The only allowed methods are:
GET
HEAD
POST
Apart from the headers set automatically by the user agent (for example, Connection, User-Agent, or any of the other headers with names defined in the Fetch spec as a “forbidden header name”), the only headers which are allowed to be manually set are those which the Fetch spec defines as being a “CORS-safelisted request-header”, which are:
Accept
Accept-Language
Content-Language
Content-Type (but note the additional requirements below)
Last-Event-ID
DPR
Save-Data
Viewport-Width
Width
The only allowed values for the Content-Type header are:
application/x-www-form-urlencoded
multipart/form-data
text/plain

Unlike “simple requests” (discussed above), "preflighted" requests first send an HTTP request by the OPTIONS method to the resource on the other domain, in order to determine whether the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.

In particular, a request is preflighted if any of the following conditions is true:

If the request uses any of the following methods:
PUT
DELETE
CONNECT
OPTIONS
TRACE
PATCH
Or if, apart from the headers set automatically by the user agent (for example, Connection, User-Agent, or any of the other header with a name defined in the Fetch spec as a “forbidden header name”), the request includes any headers other than those which the Fetch spec defines as being a “CORS-safelisted request-header”, which are the following:
Accept
Accept-Language
Content-Language
Content-Type (but note the additional requirements below)
Last-Event-ID
DPR
Save-Data
Viewport-Width
Width
Or if the Content-Type header has a value other than the following:
application/x-www-form-urlencoded
multipart/form-data
text/plain
Or if one or more event listeners are registered on an XMLHttpRequestUpload object used in the request.
Or if a ReadableStream object is used in the request.

The cors request sends Access-Control-Request-<Any type that is sent extra or other than the ones allowed>: requested types. In response we get Access-control-Allow-<Any type that is sent extra or other than the ones allowed>: the allowed types.

Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400

Access-Control-Allow-Methods, Access-Control-Allow-Headers,  Access-Control-Allow-Origin, Access-Control-Max-Age,  Access-Control-Allow-Credentials, Access-Control-Expose-Headers

Access-Control-Max-Age tells for how much time should the results or response headers from preflight request  are supposed to be cached and once the time ends a new prflight request is supposed to be made.

Redirects in normal ajax requests are allowed but not in preflight requests. If there is a redirection in preflight requests then error is generated.

In order to by pass them we can do following things

change the server-side behavior to avoid the preflight and/or to avoid the redirect—if you have control over the server the request is being made to
change the request such that it is a simple request that doesn’t cause a preflight
But if it’s not possible to make those changes, then another way that may be possible is to this:

Make a simple request to determine (using Response.url for the Fetch API, or XHR.responseURL to determine what URL the real preflighted request would end up at).
Make another request (the “real” request) using the URL you obtained from Response.url or XMLHttpRequest.responseURL in the first step.

When doing CORS requests the request will actually execute without issues but client side libraries will not allow to capture the response if the headers are not correct. The response can still be seen in inspect window or browser.

So in case of with credentials request client will try to send the request along with the credentials set by responsding server but will generate error if it does not contain correct response headers from server.

Using withCredentials from client doesn't make a preflight request, the request will still be the simple request but will expect correct response headers to be set.

When using withCredentials, the server response header Access-Control-Allow-Origin should not be * because then it will allow all the hosts and doamins to send the credentials to the server. So when using withCredentials Access-Control-Allow-Origin should be set to specific host values.

The Access-Control-Expose-Headers header lets a server whitelist headers that browsers are allowed to access. For example:

Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header
This allows the X-My-Custom-Header and X-Another-Custom-Header headers to be exposed to the browser.

Jquery No Conflict
While initialising jquery all the old references of $ are recorded $.noConflict() just restores them back. This is incase we are using any other libraries that use jquery like $ variable. For Jquery $ is just a alias to jQuery.
<script src="other_lib.js"></script>
<script src="jquery.js"></script>
<script>
$.noConflict();
// Code that uses other library's $ can follow here.
</script>

Once noConflict has been made we will not be able to use $ from jQuery direcly in the script because now in the script $ will refer to other library's $.

but still we can do few things like using the $ vairable inside the .ready(function($) {}) which can be registered as 
<script src="other_lib.js"></script>
<script src="jquery.js"></script>
<script>
$.noConflict();
jQuery( document ).ready(function( $ ) {
  // Code that uses jQuery's $ can follow here.
});
// Code that uses other library's $ can follow here.
</script>
jQuery.noConflict(); // restores $ back to previously using library. 
// Do something with jQuery
jQuery( "div p" ).hide();
// Do something with another library's $()
$( "content" ).style.display = "none";

or 
jQuery.noConflict();
(function( $ ) {
  $(function() {
    // More code using $ as alias to jQuery
  });
})(jQuery);
 
// Other code using $ as an alias to the other library



Bind method in javascript is used to change the reference of this ina method. It defines what will this keyword refer to in a method. Which can be used later.
Bind method also is ussed in currying it can take first argument as the object to which this is bound to and rest can be the arguments supplied to the function.

When http form method is not supported it converts it to GET. So in case of put or other requests the request finally gets converted to get so thats why wee need to send a post request witha a hidden field that defines the http method. 

Apache automatically adds conditional request headers in responnse such as E-Tag and Last MModified if the pages are served by apache but incases such as php fpm where pages are not served by apache or in case of pretty urls these headers are not added hence at that time we might need to add such headers manually.

Apache for adding these headers makes use of three things 
Inode -  i-node is the number generated by OS to keep track of the file, it includes things like access level, creation time,... You can configure apache to use only INode by adding this line to httpd.conf
file Mtime
file size.

Inode is different for different os even for same file and hence in case of load balancer these file will always result in complete download making etags useless.

Hence we might now at all use etags and only use cache control headers or we can change the FileEtag information to include only mtime and size.

This is already fixed in apache version 2.4 or higher and inode is removed.


Http has a concept of conditional requests which means that the result or even the success of the request can be changed based on the result that we get after comparing the resource which we are trying to access with the value of validator.

These validators are some special headers sent in the request or sent back in response which make a precondition to check based on which the resource is either returned or not.

HTTP conditional requests are requests that are executed differently, depending on the value of specific headers. These headers define a precondition, and the result of the request will be different if the precondition is matched or not.

The different behaviors are defined by the method of the request used, and by the set of headers used for a precondition:

for safe methods, like GET, which usually tries to fetch a document, the conditional request can be used to send back the document, if relevant only. Therefore, this spares bandwidth.
for unsafe methods, like PUT, which usually uploads a document, the conditional request can be used to upload the document, only if the original it is based on is the same as that stored on the server.

Validators check a specific version of a resource on the server and hence they need to send a version tex or number in the header because its not always possible and efficient to match the document byte by byte and the headers or tyoe of headers that contain such values ( version identifiers ) are called validators.

Validators are of two types 
last modified date.
etag or entity tag which contains a unique identifier for the resource.

Compairing versions is done in two ways
Weak Validation and Strong Validation.

Strong Vaildation compairs complete byte to byte value of the resource and guarantees that resourbce is exactly same.
Weak validation does not match the resource byte by byte . The two resource must be equivalent but not necessarily equal. The two resrouces are considered equal even if they are slightly different for example having a different date in footer.

The kind of validation is independent of the validator used. Both Last-Modified and ETag allow both types of validation, though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.

Header adding enabling removing and editing in htaccess is possible only because of mod_headers.

RequestHeader append MirrorID "mirror 12"
RequestHeader unset MirrorID

#Header add X-Frame-Options "DENY"


RequestHeader  edit "If-None-Match" "^(.*)-gzip$" "$1"
Header  edit "ETag" "-gzip" ""

Above is similar to DeflateAlterETag which allows to handle how etags are generated per response
AddSuffix
Append the compression method onto the end of the ETag, causing compressed and uncompressed representations to have unique ETags. This has been the default since 2.4.0, but prevents serving "HTTP Not Modified" (304) responses to conditional requests for compressed content.

NoChange
Don't change the ETag on a compressed response. This was the default prior to 2.4.0, but does not satisfy the HTTP/1.1 property that all representations of the same resource have unique ETags.

Remove
Remove the ETag header from compressed responses. This prevents some conditional requests from being possible, but avoids the shortcomings of the preceding options.

So All these headers need to be implemented on server side these are just some standard and there no specific implementations for them. Browsers only obey the data sent from server . They will only add conditional headers when there is specific response from server. So if we are sending 304 all the time then conditional heders will not be sent they will only be sent when response is 200 OK.

So for weak etag validation a prefix of W/ is used which is also the responsibility of server to implement . Client browser has nothing to do with it. Browser sends back whatever server sent to it initially.

All the conditional requests are supposed to be handeled manually ( sending correct response headers from server or client if not already sent )

If-Unmodified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT

If-Modified-Since can/should only be used with GET and HEAD requests.
If-Unmodified-Since can/should only be used with POST requests.

The If-Unmodified-Since request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a POST or another non-safe method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a 412 (Precondition Failed) error.

Etag form server response has If-Match and If-None-Match 

Etag and If-Match and If-None-Match can take multiple Etags which will be the responsibility of the server and developer to match against a valid set of etags and there nothing that will happen automatically so we can use this technique to manage version of files on different servers like in case of load balancer.

Cache-Control header is used to tell the browser what to do with the cache
max-age:  tells the browser the time in seconds till which the cache will be considered fresh.
no-cache: tells the browser to cache the content but before using it must revalidate all the times using conditional requests.
no-store: The no-store directive is more strict, it means the response cannot be written to the cache at all. Ex. If you send no-store for a response then cache wont store it at all and next time when it gets request for that resource it will send that request to the originating server, which will send the full response with HTTP 200 status 
must-revalidate: will tell the browser to validate the cache to check if its ok or stale otherwise reject the cache.

Expire also works same as cache-control max-age directive but in this we can give excat data and time for the cache to expire.

If there is a Cache-Control header with the "max-age" or "s-maxage" directive in the response, the Expires header is ignored.

If there are no conditional headers in 200 ok response headers then there will be no conditional headers in the requests also.

Chrome behaves differently for cache-control headers, hitting a url in address bar or ctrl+R or ctrl+shift+R doesnot honor cache-control headers its sends a request to server. Chrome will honor cache-control headers only when coming by clicking a link or hitting back button.

But if the response is 304 then chrome will pull data from cache only and not from server as in case of 200 ok.
Cache-Control header works perfectly in firefox.

If etag or lastModified header were not present then soon after the cache timed out it would have done a 200 ok request which would have given fresh copy and more time taking .

inorder to open new window and not a tab we need to give height and with of the window 
 window.open("https://www.w3schools.com", "_blank", "location=no,height=300,width=400");

Except for the ranges request for all the other requests if conditions specified in conditional request headers is ok then 304 not modified response is sent back and the ccontent is picked from the cache otherwise is conditions fail then for safe requests like GET and HEAD a direct 200 ok response is sent back and for unsafe requests like PUT and POST if condition matches then 304 Not Modified else if condition doesn't match then 412 precondition fail response is sent back. After getting 412 response we can reload the page or fetch the new content.

If-unmodified-since and IF-Match and If-Not-Match when used for unsafe requests like post and put they are generally used for updating a form field by editing inside a textarea or an editor. They cannot be used for uploading and replaceing or updating the documents because we will not be able to know the Last Modified date or a=original ETag for such documents where as for the post and put requests for updating an editorial for example we can use ajax requests and while we open the editor we can record the etag or Last Modifed given by the server Or when we click on edit button at that time we can generate these conditional header values.

$.fn gives a prototype object for jquery 
$.fn.check creates a method on jquery object which can be invoked later as $(document).check()
$.extend merges two or more objects into one.
$.fn.extend extends $.fn prototype object of jquery so that we can add new methods to it 
<script>
jQuery.fn.extend({
  check: function() {
    return this.each(function() {
      this.checked = true;
    });
  },
  uncheck: function() {
    return this.each(function() {
      this.checked = false;
    });
  }
});
 
// Use the newly created .check() method
$( "input[type='checkbox']" ).check();

During the partial download 
First the request goes to server to download the file
Then server response by broadcasting that it supports partial downloads by sending Accept-Ranges: bytes header. So that browser now knows that request can be partially downloaded and resumed in sometime future. Along with other headers such as Last Modified and ETag.

File starts downloading but if something goes wrong in between the download and download couldn't complete then browser can resume the download anytime by sennding Ranges request which will have the next set of bytes or range of bytes to be fetched from server which were not downloaded.

But In all this if file file on server gets changed then we will two different copies of files for the given byte ranges and hence we use conditional reqest headers here ETag and Last Modified .
The client sends along with the ranges request If-Match Or If-Not-Match or If-Modified-Since or If-Unmodified-Since which can be used on server to decide if the resource being downloaded is still same or has changed. If resource has changed then server responds with 416 precondition fails error and clients then start a totally new request with 200 OK status.

This above process of determining if r esource is intact is having extra round trips and headers to check and hence another header If-Range which also takes ETag like If-Match but in case of range allows servers to respond with directly with 200 OK as in case of GET requests when If-Match or other conditional headers fail. 
Otherwise if everything is ok then server responds with 206 partial content request.

The Range HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one Range header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the 206 Partial Content for the response. If the ranges are invalid, the server returns the 416 Range Not Satisfiable error. The server can also ignore the Range header and return the whole document with a 200 status code.

Directives
<unit>
The unit in which ranges are specified. This is usually bytes.
<range-start>
An integer in the given unit indicating the beginning of the request range.
<range-end>
An integer in the given unit indicating the end of the requested range. This value is optional and, if omitted, the end of the document is taken as the end of the range.


Syntax
Range: <unit>=<range-start>- // from given start till end.
Range: <unit>=<range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>

Examples
Range: bytes=200-1000, 2000-6576, 19000-

To distinguish between XHR requests and fetch api requests we dont have any specific mechanism because fetch api requests don't send x-forwarded for request header. Hence we need to send some extra header in order to notify that request is and fetch api request.
$.getJson and $.getScript both are similar to having dataType value json and script.
$.get and $.post both have dataType as last parameter.

$( "#b" ).load( "article.html #target" );

using xhr: inside ajaxSetup doesn't work but using xhr: field inside $.ajax works fine.

Using flush technique in ajax also works so ajax can keep receiving response from server as in case of normal web request but for it the ready state is 3 which means some data is received but not all.

Hence in XmlHttprequest we can use onreadystatechange without checking onreadystate value and keep receiving the output or also in on progress event or xmlhttp. In jquery ajax we need to use $.ajax to receive such outputs $.get won't work and in this case we also need to use it directly inside $.ajax as a property and not inside $.ajaxSetup.


If a client makes a request of your service with a Range header, return a 206 Partial Content response containing a Content-Range header and the requested range of bytes for the resource in the body. The Content-Length value should be the length of what is actually returned and not the full length of the resource.

If the client makes a range request that is out of bounds—that is, none of the range values overlap the extent of the resource—the service should respond with a 416 Requested Range Not Satisfiable status.

Range requests can also be used to read data from the file on server in chunks or bytes or unit specified in Accept-Range header.

Range requests are supposed to be made by clients explicitly they are never fired implicitly.

Somtimes in ajax requests we might not get all response headers and hence we may need to use Access-Control-Expose-Headers