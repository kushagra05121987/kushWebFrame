{"version":3,"sources":["webpack:///webpack/bootstrap 5aa9a31ae4a349950b9a","webpack:///./js/es6.js"],"names":["idMaker","yielder","anotherGenerator","generator","logGenerator","logGenerator2","logGenerator3","a","console","log","s","ar","obj","two","three","push","func1","f2","f3","f1o","func2","f4","f5","f2o","func3","param","index","gen","next","value","i","gen2","gen3","funcX","b","length","name","prototype","Object","create","func"],"mappings":"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","file":"es6.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 328);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5aa9a31ae4a349950b9a","// let\r\n// let can be used as a more stricter version of var. Where in let declaring the same variable multiple times is not allowed but assigning it multiple times is allowed. let variables are not hoisted. let is block scoped instead of function scoped.\r\nlet a = 20;\r\nif (true) {\r\n    let a = 30;\r\n}\r\nconsole.log(a);\r\n// let a = 40; // generates error that a has already been declared.\r\na = 50; // this works\r\nconsole.log(a);\r\n\r\n// const\r\n// const is stricter form of let where in any variable initialised once using const cannot be declared or assigned again.\r\nconst s = \"kushagra\";\r\n// s = \"mishra\" // throws error cannot assign\r\n\r\n// but both let and const do not stop from appending to the already assigned value.\r\nconst ar = [1, 2, 3, 4, 5];\r\nconst obj = { \"one\": 1, two: 2, three: 3 };\r\n\r\nobj['four'] = 4;\r\nar.push(6);\r\n\r\nconsole.log(ar)\r\nconsole.log(obj);\r\n\r\n// Arrow functions\r\n// Inside arrow functions the 'this' keyword remains unchanged so we dont need to use var self = this.\r\n// Arrow function take two forms expression or body.\r\n// we using expression a return is automatically prepended to the expression so we dont need to do return (expression).\r\n// we cannot use new keyword with arrow functions\r\n// Arrow functions are all anonymous.\r\n// Arrow functions will also not get hoisted.\r\n// Arrow functions do not have constructor or prototype property and thats why they are not allowed to be used with new keyword. ES6 has separated methods (arrow functions) and classes (Class keyword).\r\n// Arrow functions do not have the local variable arguments as do other functions. The arguments object is an array-like object that allows developers to dynamically discover and access a functionâ€™s arguments. This is helpful because JavaScript functions can take an unlimited number of arguments. Arrow functions do not have this object.\r\nlet func1 = function () {\r\n    this.f2 = () => {\r\n        console.log(\"f2\", this);\r\n        f3();\r\n    }\r\n\r\n    var f3 = () => {\r\n        console.log(\"f3\", this);\r\n    }\r\n}\r\nlet f1o = new func1();\r\nf1o.f2();\r\n// inside f3 above we get this same as in f2 even though it is local function and not instance method.\r\n\r\nvar func2 = function () {\r\n    console.log(this);\r\n    this.f4 = function () {\r\n        console.log(\"f4\", this);\r\n        f5();\r\n    }\r\n\r\n    var f5 = function () {\r\n        console.log(\"f5\", this);\r\n    }\r\n}\r\n// func2(); // because we are usign webpack we will get 'this' as undefined because with webpack all the code is executed inside another scope and not in window scope. Otherwise in above example we get window as value of 'this'.\r\nlet f2o = new func2();\r\nf2o.f4();\r\n\r\n// If there is only one argument in arrow function then we don't even need () \r\n// so \r\nlet func3 = param => ({ \"receivedParams\": param });\r\n(() => console.log(func3(30)))();\r\n\r\n// Generators \r\n// using yield we can construct generators. The function in generators is replaced by function* name(){}. Generator functions are not constructible so new keyword will generate error with generator functions. yield* will call another generator function. next() will stop on first occurance of yield and then will return an object with value having the first yield.\r\n\r\n// Generator function don't get executed immediately. When we call generator functions the return an iterator object, calling next() on this object will execute the body of the generator and will return object with value and done boolean indicating if generator is complete.\r\n\r\n// If we return any value from generator then that means is done, anything after that won't be executed.\r\n// Generator function should be called only once so that it will return generator object only once otherwise it will keep returning same generator object everytime\r\n\r\n// If we any param to generator function and that argument is not receieved in function and not used anywhere then corresponding yield expression will be replaced with that argument.\r\n\r\n// When passing values to generators from next function we need to have an yield statement ready to use it. Otherwise if there is no other yield that has been executed and pointer is not waiting at that yield then the value passed will not be replacing the yield expression using that next. Hence we will need to use another next with value in it that will replace the previous waiting yield.\r\n\r\n// So in the below example first yield is encountered inside console.log(yield 0). Here because there was no other yield available and waiting at time of calling the next() statement the value passed does not replace anything and yield simply returns 0 and hence console.log doesnot print anything. When we call another next at that time we have previous yield from yield 0 inside console.log which gets replaced with the value passed. And hence we have console.log executed first with the value passed and then next yield inside console.log returns.\r\n\r\nfunction* idMaker() {\r\n    console.log(\"First\");\r\n    var index = 0;\r\n    while (index < index + 1)\r\n        yield index++;\r\n    console.log(\"Now\");\r\n}\r\n\r\nvar gen = idMaker();\r\n\r\nconsole.log(gen.next().value); // 0 // this stops on first yield and returns object with value from the first yield.\r\nconsole.log(gen.next().value); // 1 // this resumes from the last yield and stops again at next yield.\r\nconsole.log(gen.next().value); // 2\r\nconsole.log(gen.next().value); // 3\r\n\r\nfunction* yielder() {\r\n    yield 1;\r\n    yield 2;\r\n    yield 3;\r\n}\r\nvar yielder = yielder();\r\nconsole.log(\"Starting Yield .... \");\r\nconsole.log(yielder.next());\r\nconsole.log(yielder.next());\r\nconsole.log(yielder.next());\r\nconsole.log(yielder.next());\r\n\r\n\r\n// using another generator function from another generator function.\r\nfunction* anotherGenerator(i) {\r\n    yield i + 1;\r\n    yield i + 2;\r\n    yield i + 3;\r\n}\r\n\r\nfunction* generator(i) {\r\n    yield i;\r\n    yield* anotherGenerator(i);\r\n    yield i + 10;\r\n}\r\n\r\nvar gen = generator(10);\r\n\r\nconsole.log(gen.next().value); // 10\r\nconsole.log(gen.next().value); // 11\r\nconsole.log(gen.next().value); // 12\r\nconsole.log(gen.next().value); // 13\r\nconsole.log(gen.next().value); // 20\r\n\r\n//   Passing arguments into Generators\r\nfunction* logGenerator() {\r\n    console.log(0);\r\n    console.log(1, yield);\r\n    console.log(2, yield);\r\n    console.log(3, yield);\r\n}\r\n\r\nfunction* logGenerator2() {\r\n    console.log(1, yield 1);\r\n    console.log(2, yield 2);\r\n    console.log(3, yield 3);\r\n}\r\n\r\n\r\nvar gen = logGenerator();\r\nvar gen2 = logGenerator2();\r\n\r\n// the first call of next executes from the start of the function\r\n// until the first yield statement\r\ngen.next();             // 0\r\ngen.next('pretzel');    // 1 pretzel\r\ngen.next('california'); // 2 california\r\ngen.next('mayonnaise'); // 3 mayonnaise\r\n\r\ngen2.next();             // 0\r\ngen2.next('pretzel');    // 1 pretzel\r\ngen2.next('california'); // 2 california\r\ngen2.next('mayonnaise'); // 3 mayonnaise\r\n\r\nconsole.log(\" ======================== Generator 3 =======================\");\r\nfunction* logGenerator3() {\r\n    console.log(yield 0);\r\n    console.log('replacing 1', yield 1);\r\n    // console.log('replacing 2', yield 2);\r\n    // console.log('replacing 3', yield 3);\r\n    // console.log(\"replacing 4\", yield 10);\r\n    // console.log(\"replacing 5\",yield 4);\r\n    // console.log(\"replacing 6\",yield 9);\r\n    // while(true){\r\n    //     yield null;\r\n    //     console.log(\"hi\");\r\n    // }\r\n}\r\nvar gen3 = logGenerator3();\r\n\r\nconsole.log(\"++++++ First +++++++\");\r\nconsole.log(gen3.next('axel'));\r\nconsole.log(\"++++++ Second +++++++\");\r\nconsole.log(gen3.next('pretzel'));\r\n//   console.log(\"++++++ Third +++++++\");\r\n//   console.log(gen3.next('california'));\r\n\r\n//   console.log(\"++++++ Fourth +++++++\");\r\n//   console.log(gen3.next('mayonnaise'));\r\n//   console.log(\"++++++ Fifth +++++++\");\r\n//   console.log(gen3.next('kushagra'));\r\n//   console.log(\"++++++ Sixth +++++++\");\r\n//   console.log(gen3.next('Mishra'));\r\nlet funcX = (a,b) => {};\r\n// console.log(funcX.arguments); // arguments are there but are not accessible and generates error => Exception: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.remoteFunction\r\nconsole.log(funcX.length);\r\nconsole.log(funcX.name);\r\nconsole.log(funcX.prototype); // no prototype in arrow functions\r\nconsole.log(Object.create(funcX));\r\n// console.log(new funcX()); // so no new object of arrow functions.\r\n// arrow functions are in actual objects from Functions . Normal function are also objects but they are a different variety of objects which also represent classes. Thats why they have prototype and all other properties such as arguments available with them. But as now in ES6 classes have come in so arrow functions represent only objects similar to array or json which donot have prototype or other properties. Arrow functions only have __proto__ property assigned to them along with name, length , etc which are also available with other object such as array. The proto as in any other object contains prototype of Function.\r\n\r\n// Default parameter\r\nlet func = (a, b=10) => {\r\n    console.log(a,b);\r\n}\r\nfunc(20);\r\nfunc(40);\n\n\n// WEBPACK FOOTER //\n// ./js/es6.js"],"sourceRoot":""}